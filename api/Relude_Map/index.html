<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Map (api.Relude_Map)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Map</nav><h1>Module <code>Relude_Map</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('key, 'value, 'id)</code><code> = Belt.Map.t<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span></code>;</dt></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Construct a new, empty map.</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">let</span> set: <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Set the value to the provided value at the given key in the map. This will add a new key if the map doesn't currently have the provided key, or it will replace the value if the key exists.</p><p>As with other operations that &quot;change&quot; a map, the original map is not mutated; instead a new immutable copy is returned.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">let</span> singleton: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Contruct a new map from the provided key and value.</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a map is empty.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a map contains a given key.</p></dd></dl><dl><dt class="spec value" id="val-compareInt"><a href="#val-compareInt" class="anchor"></a><code><span class="keyword">let</span> compareInt: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> int)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>Compare the ordering of two maps, given a comparator function capable of comparing each value in the map. <code>compareInt</code> expects the provided function to return an int representing the comparison, and <code>compareInt</code> intself will return an int.</p></dd></dl><dl><dt class="spec value" id="val-compareBy"><a href="#val-compareBy" class="anchor"></a><code><span class="keyword">let</span> compareBy: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> BsBastet.Interface.ordering)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> BsBastet.Interface.ordering;</code></dt><dd><p>Compare the ordering of two maps, given a comparator function capable of comparing each value in the map. <code>compare</code> expects the provided function to return an <code>ordering</code> representing the comparison, and <code>compare</code> itself will return an <code>ordering</code> value.</p></dd></dl><dl><dt class="spec value" id="val-eqBy"><a href="#val-eqBy" class="anchor"></a><code><span class="keyword">let</span> eqBy: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Given an equality function capable of testing values for equality, determine whether two maps are equal by checking whether they have equal keys, and equal values at each key.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>Find (optionally) the first key/value pair in a map matching the provided predicate function.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Iterate over each key/value pair in the map, calling the provided function that probably performs some side effect and returns <code>unit</code>. Prefer <code>map</code> or <code>foldLeft</code> in most cases.</p></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Accumulate a map of key/value pairs into a single value.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Given a predicate function to be called with key/value pairs, determine whether every pair in the map satisfies the predicate. This will always return <code>true</code> for empty maps.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Given a predicate function to be called with key/value pairs, determine whether at least one pair in the map satisfies the predicate. This will always return <code>false</code> for empty maps.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>The count of keys in the map.</p></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>Convert a map to an array of key/value pairs. Note that the resulting array will be sorted by the ordering of the key type, not necessarily the order in which values were added to the map.</p></dd></dl><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Convert an associated array (an array of (key, value) tuples) into a map.</p></dd></dl><dl><dt class="spec value" id="val-fromValueArray"><a href="#val-fromValueArray" class="anchor"></a><code><span class="keyword">let</span> fromValueArray: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Convert an array of values into a map, using the provided function from value to key. This is useful when your value type can already be uniquely identified (and that identifier can be ordered).</p></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>Convert a map to an associated list (a list of key/value tuples). Note that the resulting list will be sorted according to the ordering of the key type, not necessarily in the order in which values were added to the map.</p></dd></dl><dl><dt class="spec value" id="val-fromList"><a href="#val-fromList" class="anchor"></a><code><span class="keyword">let</span> fromList: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Convert an associated list (a list of (key, value) tuples) into a map.</p></dd></dl><dl><dt class="spec value" id="val-fromValueList"><a href="#val-fromValueList" class="anchor"></a><code><span class="keyword">let</span> fromValueList: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Convert a list of values into a map, using the provided function from value to key. This is useful when your value type can already be uniquely identified (and that identifier can be ordered).</p></dd></dl><dl><dt class="spec value" id="val-keyArray"><a href="#val-keyArray" class="anchor"></a><code><span class="keyword">let</span> keyArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'key</span>);</code></dt><dd><p>Return a sorted array containing each key in the map.</p></dd></dl><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">let</span> keys: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'key</span>);</code></dt><dd><p>Return a sorted list containing each key in the map</p></dd></dl><dl><dt class="spec value" id="val-valueArray"><a href="#val-valueArray" class="anchor"></a><code><span class="keyword">let</span> valueArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>);</code></dt><dd><p>Return an array of each value (sorted by key) in the map.</p></dd></dl><dl><dt class="spec value" id="val-values"><a href="#val-values" class="anchor"></a><code><span class="keyword">let</span> values: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>);</code></dt><dd><p>Return a list of each value (sorted by key) in the map.</p></dd></dl><dl><dt class="spec value" id="val-minKey"><a href="#val-minKey" class="anchor"></a><code><span class="keyword">let</span> minKey: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'key</span>);</code></dt><dd><p>Optionally find the smallest key, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-maxKey"><a href="#val-maxKey" class="anchor"></a><code><span class="keyword">let</span> maxKey: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'key</span>);</code></dt><dd><p>Optionally find the largest key, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>Optionally find the smallest key/value pair, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>Optionally find the largest key/value pair, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>Attempt to find a value in a map, given a key.</p></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'value</span>;</code></dt><dd><p>Attempt to find a value in a map, given a key. Use the provided fallback value if the key is not in the map.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Return a new copy of a map, with the provided key removed. Like other map functions that &quot;change&quot; a value, this returns an immutable copy. The original map is unchanged.</p></dd></dl><dl><dt class="spec value" id="val-removeMany"><a href="#val-removeMany" class="anchor"></a><code><span class="keyword">let</span> removeMany: array(<span class="type-var">'key</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Given a list of keys, remove each from the map, returning a new copy.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">let</span> update: <span class="type-var">'key</span> <span>=&gt;</span> <span>(option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>At the given key, set or remove the value using the provided update function. The function will be called with the current value, if any. It may return <code>Some(newValue)</code> which will perform a <code>set</code>, or it can return <code>None</code>, which will perform a <code>remove</code>.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">let</span> merge: <span>(<span class="type-var">'key</span> <span>=&gt;</span> option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Combine two existing maps using the provided merge function. The merge function will be called with the key being merged as well as the two possible values from the existing maps. The provided merge function should return <code>None</code> to remove a key, or <code>Some(newValue)</code> to keep the key.</p><p>The value types of the two original maps don't need to be the same, nor does the value type returned by the provided merge function.</p></dd></dl><dl><dt class="spec value" id="val-mergeMany"><a href="#val-mergeMany" class="anchor"></a><code><span class="keyword">let</span> mergeMany: array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Given an array of key/value pairs and an existin map, add each key and value in the array to the map.</p><p>TODO: it's not clear from the Belt docs what happens in the case of key conflicts.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Remove each key/value pair that doesn't pass the given predicate function.</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">let</span> keep: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Alias of filter</p></dd></dl><dl><dt class="spec value" id="val-filterNot"><a href="#val-filterNot" class="anchor"></a><code><span class="keyword">let</span> filterNot: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Remove each key/value pair that passes the given predicate function</p></dd></dl><dl><dt class="spec value" id="val-reject"><a href="#val-reject" class="anchor"></a><code><span class="keyword">let</span> reject: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Alias of filterNot</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">let</span> partition: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>;</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: <span>(<span class="type-var">'v1</span> <span>=&gt;</span> <span class="type-var">'v2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v1</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v2</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Transform each value in the map to a new value using the provided function.</p></dd></dl><dl><dt class="spec value" id="val-mapWithKey"><a href="#val-mapWithKey" class="anchor"></a><code><span class="keyword">let</span> mapWithKey: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'v1</span> <span>=&gt;</span> <span class="type-var">'v2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v1</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v2</span>, <span class="type-var">'id</span>)</span>;</code></dt><dt class="spec value" id="val-groupListBy"><a href="#val-groupListBy" class="anchor"></a><code><span class="keyword">let</span> groupListBy: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, list(<span class="type-var">'value</span>), <span class="type-var">'id</span>)</span>;</code></dt><dt class="spec value" id="val-groupArrayBy"><a href="#val-groupArrayBy" class="anchor"></a><code><span class="keyword">let</span> groupArrayBy: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, array(<span class="type-var">'value</span>), <span class="type-var">'id</span>)</span>;</code></dt></dl><div class="spec module-type" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP">MAP</a> = { ... };</code></div><div class="spec module" id="module-WithOrd"><a href="#module-WithOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="WithOrd">WithOrd</a>:  (<a href="WithOrd#argument-1-M">M</a>: BsBastet.Interface.ORD) <span>=&gt;</span> <a href="#module-type-MAP">MAP</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithOrd#type-key">key</a> = <a href="WithOrd#argument-1-M">M</a>.t;</code></div></div></body></html>