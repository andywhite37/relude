<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Result (api.Relude_Result)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Result</nav><h1>Module <code>Relude_Result</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span></code><code> = </code><table class="variant"><tr id="type-t.Ok" class="anchored"><td class="def constructor"><a href="#type-t.Ok" class="anchor"></a><code>| </code><code><span class="constructor">Ok</span>(<span class="type-var">'a</span>)</code></td></tr><tr id="type-t.Error" class="anchored"><td class="def constructor"><a href="#type-t.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span>(<span class="type-var">'e</span>)</code></td></tr></table>;</dt></dl><dl><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">let</span> ok: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.ok</code> constructs an <code>Ok</code> result from the provided value.</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">let</span> error: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.error</code> constructs an <code>Error</code> result from the provided value.</p><pre><code class="ml">Result.error(&quot;Not even&quot;) == Error(&quot;Not even&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">let</span> unit: e. <a href="#type-t">t</a><span>(unit, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.unit</code> is an <code>Ok</code> value that holds <code>()</code>.</p><pre><code class="ml">Result.unit == Ok();</code></pre></dd></dl><dl><dt class="spec value" id="val-getOk"><a href="#val-getOk" class="anchor"></a><code><span class="keyword">let</span> getOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p><code>Result.getOk</code> converts a <code>result</code> to an <code>option</code>, returning <code>Some</code> when the result was <code>Ok</code> and <code>None</code> if the result was an <code>Error</code>.</p><pre><code class="ml">Result.getOk(Ok(1066)) == Some(1066);
Result.getOk(Error(&quot;bad value&quot;)) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-toOption"><a href="#val-toOption" class="anchor"></a><code><span class="keyword">let</span> toOption: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p><code>Result.toOption</code> is an alias for <a href="#val-getOk"><code>getOk</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-getError"><a href="#val-getError" class="anchor"></a><code><span class="keyword">let</span> getError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'e</span>);</code></dt><dd><p><code>Result.getError</code> converts a <code>result</code> to an <code>option</code>, turning a result <code>Error</code> into <code>Some</code> (constructed with the error payload), or returning <code>None</code> if the provided result was <code>Ok</code>.</p><pre><code class="ml">Result.getError(Ok(1066)) == None;
Result.getError(Error(&quot;bad value&quot;)) == Some(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-isOk"><a href="#val-isOk" class="anchor"></a><code><span class="keyword">let</span> isOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>Result.isOK</code> returns <code>true</code> when the provided result holds an <code>Ok</code> value and returns <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isError"><a href="#val-isError" class="anchor"></a><code><span class="keyword">let</span> isError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>Result.isError</code> returns <code>true</code> when the provided result holds an <code>Error</code> value and returns <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: a e c. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>Result.fold</code> &quot;handles&quot; both possible cases in a result. The first function maps the inner error to a new type, and the second function maps the ok value to that same type. This effectively lets you get <em>out</em> of the <code>result</code> context.</p><p>A good example of this is a React reducer, where some operation could either fail or succeed, but either way, you want to convert that into an <code>action</code> to update your application state.</p><pre><code class="ml">// imagine this tries to load data from some synchronous store like
// localstorage, but it could fail to find or decode the data
let nextAction =
  loadTasks()
  |&gt; Result.fold(
    _err =&gt; SetDataFailure(&quot;Data could not be loaded&quot;),
    data =&gt; UpdateData(data)
  );

// now, regardless of whether our result was successful, we have an action
dispatch(nextAction);</code></pre></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>Result.getOrElse</code> attempts to get the <code>Ok</code> value out of a <code>result</code>. If the result is an <code>Error</code>, the provided default value is returned instead.</p><pre><code class="ml">// imagine a function to calculate an average from a array of floats, but it
// safely prevents division by zero by returning a result
let safeAvg = (values: array(float)) =&gt;
  switch (Array.length(values)) {
  | 0 =&gt; Error(&quot;Cannot calculate average&quot;)
  | len =&gt;
    let total = Array.Float.sum(values);
    Ok(total /. Int.toFloat(len))
  };

Result.getOrElse(0.0, safeAvg([|12.3, 9.6, 4.7, 10.8|])) == 9.35;
Result.getOrElse(0.0, safeAvg([||])) == 0.0;</code></pre></dd></dl><dl><dt class="spec value" id="val-getOrElseLazy"><a href="#val-getOrElseLazy" class="anchor"></a><code><span class="keyword">let</span> getOrElseLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>Result.getOrElseLazy</code> attempts to get the <code>Ok</code> value out of a <code>result</code>. If the result is an <code>Error</code>, a default value is returned by calling the provided function instead.</p><p>This function is similar to <a href="#val-getOrElse"><code>getOrElse</code></a>, but in this case the default only gets constructed if it's actually needed. This can be useful if the fallback value is expensive to compute.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">let</span> merge: a. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>Result.merge</code> returns the inner value from the <code>result</code>. This requires both the <code>Ok</code> and <code>Error</code> channels to hold the same type of value.</p><p>This is especially useful in cases where you've &quot;handled&quot; the error half using something like <a href="#val-mapError"><code>mapError</code></a>, and you now want to get the value out. In many cases, though, <a href="#val-fold"><code>fold</code></a> is probably the simpler alternative.</p><pre><code class="ml">let userGreeting =
  decodeUser(data) // imagine this returns a result
  |&gt; Result.map(user =&gt; &quot;Hello &quot; ++ user.firstName ++ &quot;!&quot;)
  |&gt; Result.mapError(_ =&gt; &quot;Hello unknown user!&quot;)
  |&gt; Result.merge;

// if the decode failed...
userGreeting == &quot;Hello unknown user!&quot;;

// if it succeeded...
userGreeting == &quot;Hello Alice!&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p><code>Result.flip</code> swaps the values between the <code>Ok</code> and <code>Error</code> constructors.</p><pre><code class="ml">flip(Ok(3)) == Error(3);
flip(Error(&quot;hello&quot;)) == Ok(&quot;hello&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>map(f, x)</code> returns <code>Ok(f(x))</code> if <code>x</code> is of the form <code>OK(v)</code>. It returns <code>Error(e)</code> if <code>x</code> is of the form <code>Error(e)</code>.</p><pre><code class="ml">map(x =&gt; sqrt(float_of_int(x)), Ok(4)) == Ok(2.0);
map(x =&gt; sqrt(float_of_int(x)), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;);</code></pre><p>One place you might use <code>map()</code> is in validating input to an “ordinary” function. Consider the (highly artificial) example where you have a function that will cube a number, but you only want to do so if the number is even. Here are the functions:</p><pre><code class="ml">type intResult = Relude.Result.t(int, string);
let cube = (x) =&gt; {x * x * x};
let testEven = (n): intResult =&gt; {
  (n mod 2 == 0) ? Ok(n) :
    Error(string_of_int(n) ++ &quot; is not even.&quot;)
};</code></pre><p>We can now make calls like this:</p><pre><code class="ml">map(cube, testEven(12)) == Ok(1728);
map(cube, testEven(5)) == Error(&quot;5 is not even.&quot;);</code></pre><p>This is something we could have done with a simple <code>if</code> statement, but we will see <code>map()</code> become useful when we have several things to validate. (See <code>apply()</code> and <code>map2()</code>, <code>map3()</code>, etc.)</p></dd></dl><dl><dt class="spec value" id="val-mapOk"><a href="#val-mapOk" class="anchor"></a><code><span class="keyword">let</span> mapOk: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>;</code></dt><dd><p><code>mapOk</code> is an alias for <a href="#val-map"><code>map</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p><code>mapError(f, x)</code> returns <code>Ok(v)</code> if <code>x</code> is of the form <code>OK(v)</code>. It returns <code>Error(f(e))</code> if <code>x</code> is of the form <code>Error(e)</code>.</p><pre><code class="ml">Result.mapError(x =&gt; &quot;Err: &quot; ++ x, Ok(4)) == Ok(4);
Result.mapError(x =&gt; &quot;Err: &quot; ++ x, Error(&quot;bad&quot;)) == Error(&quot;Err: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p><code>bimap(f, g, x)</code> returns <code>Ok(f(v))</code> if <code>x</code> is of the form <code>Ok(v)</code>; it returns <code>Error(g(e))</code> if <code>x</code> is of the form <code>Error(e)</code>.</p><pre><code class="ml">let cube = x =&gt; x * x * x;
let label = x =&gt; &quot;Err: &quot; ++ x;

Result.bimap(cube, label, Ok(12)) == Ok(1728);
Result.bimap(cube, label, Error(&quot;bad&quot;)) == Error(&quot;Err: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>tap(f, x)</code>, function <code>f()</code> returns <code>unit</code>. Thus, <code>f()</code> is used only for its side effects. If <code>x</code> is of the form <code>Ok(v)</code>, <code>tap()</code> calls <code>f(v)</code>. The <code>tap()</code> function returns the argument <code>x</code>.</p><pre><code class="ml">Result.tap(x =&gt; Js.log(x), Ok(4)) == Ok(4); // prints 4
Result.tap(x =&gt; Js.log(x), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;); // prints nothing</code></pre></dd></dl><dl><dt class="spec value" id="val-tapOk"><a href="#val-tapOk" class="anchor"></a><code><span class="keyword">let</span> tapOk: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.tapOk</code> is an alias for <a href="#val-tap"><code>tap</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>tapError(f, x)</code>, function <code>f()</code> returns <code>unit</code>. Thus, <code>f()</code> is used only for its side effects. If <code>x</code> is of the form <code>Error(v)</code>, <code>tap()</code> calls <code>f(v)</code>. The <code>tap()</code> function returns the argument <code>x</code>.</p><pre><code class="ml">tapError(x =&gt; Js.log(x), Ok(4)) == Ok(4); // prints nothing
tapError(x =&gt; Js.log(x), Error(&quot;bad&quot;)) == Error(&quot;bad&quot;); // prints &quot;bad&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>apply(fcn, x)</code> provides a way of creating a chain of validation functions.</p><p>If <code>fcn</code> is of the form <code>Ok(f)</code>, function <code>f</code> is applied to <code>x</code>. If <code>x</code> is <code>Ok(v)</code>, the result is <code>Ok(f(v))</code>. If <code>x</code> is <code>Error(err)</code>, the error is passed onwards.</p><p>If <code>fcn</code> is itself of the form <code>Error(err)</code> and <code>x</code> is <code>Ok(v)</code>, <code>Error(err)</code> is passed on.</p><p>Finally, if both <code>fcn</code> and <code>x</code> are <code>Error(e1)</code> and <code>Error(e2)</code>, the result is <code>Error(e2)</code>.</p><p>Using <code>apply()</code> properly is somewhat complex. See the example in the Validation tests for more details. (It uses <code>VOk</code> and <code>VError</code>, but the logic is identical.)</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">let</span> map2: a b c x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p><code>map2(f, x, y)</code> has as its first argument a function that takes two values. If both of <code>x</code> and <code>y</code> are of the form <code>Ok(xv)</code> and <code>Ok(yv)</code>, <code>map2()</code> returns <code>Ok(f(xv, yv))</code>. Otherwise, it returns the last value of type <code>Error(e)</code> that it encounters.</p><p>Here is another artificial example that concatenates a string and integer, but only if the string is non-empty and the number is odd:</p><pre><code class="ml">let combine = (str, n) =&gt; str ++ &quot; &quot; ++ string_of_int(n);

type strResult = Relude.Result.t(string, string);
let testStr = (s): strResult =&gt; (s == &quot;&quot;) ? Error(&quot;empty string&quot;): Ok(s);
let testOdd = (n): intResult =&gt; (n mod 2 == 0) ? Error(&quot;not odd&quot;) : Ok(n);

map2(combine, testStr(&quot;cloud&quot;), testOdd(9)) == Ok(&quot;cloud 9&quot;);
map2(combine, testStr(&quot;cloud&quot;), testOdd(10)) == Error(&quot;not odd&quot;);
map2(combine, testStr(&quot;&quot;), testOdd(9)) == Error(&quot;empty string&quot;);
map2(combine, testStr(&quot;&quot;), testOdd(10)) == Error(&quot;not odd&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">let</span> map3: a b c d x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p><code>map3(f, x, y, z)</code> has as its first argument a function that takes three values. If all of <code>x</code>, <code>y</code>, and <code>z</code> are of the form <code>Ok(xv)</code>, <code>Ok(yv)</code>, and <code>Ok(zv)</code>, <code>map3()</code> returns <code>Ok(f(xv, yv, zv))</code>. Otherwise, it returns the last value of type <code>Error(e)</code> that it encounters.</p><p>The following example builds on the example from <code>map2()</code> and does not show all the possible combinations.</p><pre><code class="ml">let combine = (str, n1, n2) =&gt; str ++ &quot; &quot; ++ string_of_int(n1 * n2);
let testLimit = (n): intResult =&gt; {(n &lt; 100) ? Ok(n) : Error(&quot;too big&quot;)};

map3(combine, testStr(&quot;cloud&quot;), testOdd(3), testLimit(3)) == Ok(&quot;cloud 9&quot;);
map3(combine, testStr(&quot;cloud&quot;), testOdd(2), testLimit(3)) == Error(&quot;not odd&quot;);
map3(combine, testStr(&quot;&quot;), testOdd(3), testLimit(3)) == Error(&quot;empty string&quot;);
map3(combine, testStr(&quot;&quot;), testOdd(10), testLimit(100)) == Error(&quot;too big&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">let</span> map4: a b c d e x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p><code>map4(f, x, y, z, w)</code> has as its first argument a function that takes four values. If all of <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> are of the form <code>Ok(xv)</code>, <code>Ok(yv)</code>, <code>Ok(zv)</code>, and <code>Ok(wv)</code>, <code>map4()</code> returns <code>Ok(f(xv, yv, zv, wv))</code>. Otherwise, it returns the last value of type <code>Error(e)</code> that it encounters.</p><p>This example uses validation functions defined in the example from <code>map3()</code>.</p><pre><code class="ml">let combine = (s1, n2, n3, n4) =&gt; {s1 ++ &quot; &quot; ++ string_of_int(n2 + n3 + n4)};
let testPositive = (n): intResult =&gt; {(n &gt; 0) ? Ok(n) : Error(&quot;not positive&quot;)};

map4(combine, testStr(&quot;car&quot;), testOdd(49), testPositive(2), testLimit(3)) == Ok(&quot;car 54&quot;);
map4(combine, testStr(&quot;car&quot;), testOdd(50), testPositive(2), testLimit(200)) == Error(&quot;too big&quot;);
map4(combine, testStr(&quot;&quot;), testOdd(49), testPositive(-5), testLimit(0)) == Error(&quot;not positive&quot;);
map4(combine, testStr(&quot;&quot;), testOdd(48), testPositive(-9), testLimit(200))
  == Error(&quot;too big&quot;); // all failures</code></pre></dd></dl><dl><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">let</span> map5: a b c d e f x. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'f</span>, <span class="type-var">'x</span>)</span>;</code></dt><dd><p><code>map5(f, x, y, z, w, q)</code> has as its first argument a function that takes five values. If all of <code>x</code>, <code>y</code>, <code>z</code>, <code>w</code>, and <code>q</code> are of the form <code>Ok(xv)</code>, <code>Ok(yv)</code>, <code>Ok(zv)</code>, <code>Ok(wv)</code>, and <code>Ok(qv)</code>, <code>map5()</code> returns <code>Ok(f(xv, yv, zv, wv, qv))</code>. Otherwise, it returns the last value of type <code>Error(e)</code> that it encounters.</p><p>The following examples do not show all the possible combinations.</p><pre><code class="ml">let combine = (s1, n2, n3, n4, n5) =&gt; {s1 ++ &quot; &quot; ++ string_of_int(n2 + n3 + n4 + n5)};
let testNegative = (n): intResult =&gt; {(n &lt; 0) ? Ok(n) : Error(&quot;not negative&quot;)};

map5(combine, testStr(&quot;square&quot;), testOdd(5), testPositive(2),
  testLimit(3), testNegative(-9)) == Ok(&quot;square 1&quot;);
map5(combine, testStr(&quot;square&quot;), testOdd(2), testPositive(5), testLimit(200),
  testNegative(-3)) == Error(&quot;too big&quot;);
map5(combine, testStr(&quot;&quot;), testOdd(3), testPositive(5), testLimit(7),
  testNegative(-9)) == Error(&quot;empty string&quot;);
map5(combine, testStr(&quot;&quot;), testOdd(2), testPositive(-2), testLimit(200),
  testNegative(42)) == Error(&quot;not negative&quot;); // all failures</code></pre></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.pure</code> wraps its argument in the <code>Ok</code> constructor.</p><pre><code class="ml">Result.pure(3) == Ok(3);</code></pre></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>bind(r, f)</code>, <code>f()</code> is a function that takes a non-<code>Result</code> argument and returns a <code>Result</code> value. If <code>r</code> is of the form <code>Ok(val)</code>, then <code>bind()</code> returns <code>f(val)</code>. Otherwise, it returns <code>r</code>, which will be an <code>Error(err)</code>.</p><p>Note: <code>bind()</code> is the same as <code>flatMap()</code>, except with the arguments in reverse order.</p><pre><code class="ml">let safeSqrt = (x): Relude.Result.t(float, string) =&gt; {
  (x &gt;= 0.0) ? Ok(sqrt(x)) : Error(&quot;cannot be negative&quot;)
};
bind(Ok(4.0), safeSqrt) == Ok(2.0);
bind(Error(&quot;invalid float&quot;), safeSqrt) == Error(&quot;invalid float&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>flatMap(f, r)</code>, <code>f()</code> is a function that takes a non-<code>Result</code> argument and returns a <code>Result</code> value. If <code>r</code> is of the form <code>Ok(val)</code>, then <code>flatMap()</code> returns <code>f(val)</code>. Otherwise, it returns <code>r</code>, which will be an <code>Error(err)</code>.</p><p>Note: <code>flatMap()</code> is the same as <code>bind()</code>, except with the arguments in reverse order.</p><pre><code class="ml">let safeSqrt = x =&gt;
  (x &gt;= 0.0) ? Ok(sqrt(x)) : Error(&quot;cannot be negative&quot;);

flatMap(safeSqrt, Ok(4.0)) == Ok(2.0);
flatMap(safeSqrt, Error(&quot;invalid float&quot;)) == Error(&quot;invalid float&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">let</span> flatten: a e. <a href="#type-t">t</a><span>(<a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.flatten</code> turns a nested result (an outer result that carries a separate result in its <code>Ok</code> channel) into one less layer of result.</p><p>Note that this only works if the inner and outer result agree about the type of the <code>Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">let</span> alt: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>alt(r1, r2)</code> takes two <code>Result</code> arguments. If both are <code>Ok(..)</code>, the first one is returned. If only one is <code>Ok(..)</code>, it is returned. If both are <code>Error(..)</code>, the last one is returned.</p><pre><code class="ml">alt(Ok(2), Ok(3)) == Ok(2);
alt(Error(&quot;bad&quot;), Ok(3)) == Ok(3);
alt(Ok(2), Error(&quot;worse&quot;)) == Ok(2);
alt(Error(&quot;bad&quot;), Error(&quot;worse&quot;)) == Error(&quot;worse&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-align"><a href="#val-align" class="anchor"></a><code><span class="keyword">let</span> align: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Converts two results into a result where either side or both sides have succeded, or a result that fails if both sides failed.</p></dd></dl><dl><dt class="spec value" id="val-alignWith"><a href="#val-alignWith" class="anchor"></a><code><span class="keyword">let</span> alignWith: a b c e. <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Similar to map2, but captures successful values from either or both sides</p></dd></dl><dl><dt class="spec value" id="val-catchError"><a href="#val-catchError" class="anchor"></a><code><span class="keyword">let</span> catchError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p><code>catchError(f, r)</code> returns <code>f(e)</code> when <code>r</code> is of the form <code>Error(e)</code>; otherwise it returns <code>r</code> (an <code>Ok</code> value) unchanged.</p><pre><code class="ml">let labelMessage = s =&gt; &quot;Attn: &quot; ++ s;

catchError(labelMessage, Ok(2)) == Ok(2);
catchError(labelMessage, Error(&quot;not even&quot;)) == Error(&quot;Attn: not even&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-handleError"><a href="#val-handleError" class="anchor"></a><code><span class="keyword">let</span> handleError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_Void.t)</span>;</code></dt><dd><p><code>handleError(f, r)</code> converts errors into successful values, and returns a Result where the error channel is voided, to indicate that the error has been handled.</p></dd></dl><dl><dt class="spec value" id="val-mapHandleError"><a href="#val-mapHandleError" class="anchor"></a><code><span class="keyword">let</span> mapHandleError: a e b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, Relude_Void.t)</span>;</code></dt><dd><p>Maps the success channel and handles an error on the error channel to end up with a Result of a new type with a voided error channel.</p></dd></dl><dl><dt class="spec value" id="val-recover"><a href="#val-recover" class="anchor"></a><code><span class="keyword">let</span> recover: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.recover</code> ensures that the returned result is <code>Ok</code> by returning the provided result if it's already <code>Ok</code>, or by falling back to the default value (which will be wrapped in the <code>Ok</code> constructor) if the provided result is an <code>Error</code>.</p><p>Note that the type returned by this function is still a <code>result</code>. In most cases, you'll probably want to get out of the result context by using <a href="#val-getOrElse"><code>getOrElse</code></a>, or you'll want to indicate to the compiler that the error channel is definitely empty by using <a href="#val-handleError"><code>handleError</code></a>.</p><pre><code class="ml">// imagine a function to calculate an average from a array of floats, but it
// safely prevents division by zero by returning a result
let safeAvg = (values: array(float)) =&gt;
  switch (Array.length(values)) {
  | 0 =&gt; Error(&quot;Cannot calculate average&quot;)
  | len =&gt;
    let total = Array.Float.sum(values);
    Ok(total /. Int.toFloat(len))
  };

Result.recover(0.0, safeAvg([|12.3, 9.6, 4.7, 10.8|])) == Ok(9.35);
Result.recover(0.0, safeAvg([||])) == Ok(0.0);</code></pre></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span class="type-var">'e</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>fromOption(defaultError, opt)</code> converts a value of the form <code>Some(v)</code> to <code>Ok(v)</code>, and converts <code>None</code> to <code>Error(defaultError)</code>.</p><pre><code class="ml">Result.fromOption(&quot;bad value&quot;, Some(3)) == Ok(3);
Result.fromOption(&quot;bad value&quot;, None) == Error(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-fromOptionLazy"><a href="#val-fromOptionLazy" class="anchor"></a><code><span class="keyword">let</span> fromOptionLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>Result.fromOptionLazy</code> turns an option into a result by converting a <code>Some</code> value from the option to an <code>Ok</code> result, or by calling the provided function to get an error value, which will be wrapped in the <code>Error</code> constructor.</p><p>Note that unlike <a href="#val-fromOption"><code>fromOption</code></a>, this function won't construct the error value unless it's needed, which is more efficient if the error is expensive to construct.</p><pre><code class="ml">let getError = () =&gt; &quot;bad value&quot;;
Result.fromOptionLazy(getError, Some(3)) == Ok(3);
Result.fromOptionLazy(getError, None) == Error(&quot;bad value&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-eqBy"><a href="#val-eqBy" class="anchor"></a><code><span class="keyword">let</span> eqBy: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>eqBy(errorEq, okEq, a, b)</code> compares <code>a</code> and <code>b</code> for equality as follows:</p><p>If both are of the form <code>Ok(..)</code> and <code>Ok(..)</code>, <code>eqBy</code> calls <code>okEq()</code> with their values and returns a boolean depending on whether they are equal or not.</p><p>If both are of the form <code>Error(..)</code>, <code>eqBy</code> calls <code>errorEq()</code> with their values and returns a boolean depending on whether they are equal or not.</p><p>In all other cases, <code>eqBy()</code> returns <code>false</code>.</p><pre><code class="ml">let clockEqual = (c1, c2) =&gt; c1 mod 12 == c2 mod 12;
let strEqual = (c1, c2) =&gt; c1 == c2;

eqBy(strEqual, clockEqual, Ok(14), Ok(2)) == true;
eqBy(strEqual, clockEqual, Ok(14), Ok(3)) == false;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Error(&quot;not an integer&quot;)) == true;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Error(&quot;not positive&quot;)) == false;
eqBy(strEqual, clockEqual, Ok(14), Error(&quot;not positive&quot;)) == false;
eqBy(strEqual, clockEqual, Error(&quot;not an integer&quot;), Ok(2)) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-tries"><a href="#val-tries" class="anchor"></a><code><span class="keyword">let</span> tries: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, exn)</span>;</code></dt><dd><p><code>Result.tries</code> calls the provided unsafe function (which may throw an exception), and returns its value safely wrapped in a <code>result</code>. If the provided function succeeds, its return value is wrapped in the <code>Ok</code> constructor. If the function throws, the exception is caught and wrapped in the <code>Error</code> constructor.</p><pre><code class="ml">tries(() =&gt; int_of_string(&quot;37&quot;)) == Ok(37);
tries(() =&gt; int_of_string(&quot;four&quot;)); // returns an exn</code></pre></dd></dl><dl><dt class="spec value" id="val-triesAsString"><a href="#val-triesAsString" class="anchor"></a><code><span class="keyword">let</span> triesAsString: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Js.String.t)</span>;</code></dt><dd><p><code>Result.triesAsString</code> handles potentially-unsafe functions similar to <a href="#val-tries"><code>tries</code></a>, but additionally converts the exception into a <code>string</code> using JavaScript's magic ability to construct a <code>string</code> from anything.</p><pre><code class="ml">Result.triesAsString(() =&gt; int_of_string(&quot;37&quot;)) == Ok(37);
Result.triesAsString(() =&gt; int_of_string(&quot;four&quot;)) ==
  Error(&quot;Failure,-2,int_of_string&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-toValidation"><a href="#val-toValidation" class="anchor"></a><code><span class="keyword">let</span> toValidation: Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p><code>toValidation(result)</code> converts <code>Ok(val)</code> to <code>VOk(val)</code> and <code>Error(err)</code> to <code>VError(err)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fromValidation"><a href="#val-fromValidation" class="anchor"></a><code><span class="keyword">let</span> fromValidation: Relude_Validation.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p><code>fromValidation(vResult)</code> converts <code>VOk(val)</code> to <code>Ok(val)</code> and <code>VError(err)</code> to <code>Error(err)</code>.</p></dd></dl><dl><dt class="spec value" id="val-toValidationNel"><a href="#val-toValidationNel" class="anchor"></a><code><span class="keyword">let</span> toValidationNel: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p><code>toValidationNel(vResult)</code> converts <code>Ok(val)</code> to <code>VOk(val)</code> and <code>Error(err)</code> to <code>VError([err])</code>, where the list is of type <code>Relude.NonEmpty.List</code>.</p><p>You use this function when you have a <code>Result</code> type that you wish to use with <code>Validation</code> in order to accumulate a list of errors.</p><pre><code class="ml">toValidationNel(Ok(1066)) == Relude.Validation.VOk(1066);
toValidationNel(Error(&quot;not odd&quot;)) == Relude.Validation.VError(
  Relude.NonEmpty.List.pure(&quot;not odd&quot;));</code></pre></dd></dl><dl><dt class="spec value" id="val-toValidationNea"><a href="#val-toValidationNea" class="anchor"></a><code><span class="keyword">let</span> toValidationNea: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Relude_Validation.t<span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p><code>toValidationNea(vResult)</code> converts <code>Ok(val)</code> to <code>VOk(val)</code> and <code>Error(err)</code> to <code>VError([|err|])</code>, where the array is of type <code>Relude.NonEmpty.Array</code>.</p><p>You use this function when you have a <code>Result</code> type that you wish to use with <code>Validation</code> in order to accumulate an array of errors.</p><pre><code class="ml">toValidationNea(Ok(1066)) == Relude.Validation.VOk(1066);
toValidationNea(Error(&quot;not odd&quot;)) == Relude.Validation.VError(
  Relude.NonEmpty.Array.pure(&quot;not odd&quot;));
toValidationNea(Error(&quot;not odd&quot;));</code></pre></dd></dl><div class="spec module" id="module-Bifunctor"><a href="#module-Bifunctor" class="anchor"></a><code><span class="keyword">module</span> Bifunctor: BsBastet.Interface.BIFUNCTOR <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifunctor">Bifunctor</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'b</span>, <span class="type-var">'d</span>)</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-mapLeft"><a href="#val-mapLeft" class="anchor"></a><code><span class="keyword">let</span> mapLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-mapRight"><a href="#val-mapRight" class="anchor"></a><code><span class="keyword">let</span> mapRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'d</span>)</span>;</code></dt><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl></details></div></div></div><div class="spec module" id="module-Bifoldable"><a href="#module-Bifoldable" class="anchor"></a><code><span class="keyword">module</span> Bifoldable: BsBastet.Interface.BIFOLDABLE <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifoldable">Bifoldable</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bifoldLeft"><a href="#val-bifoldLeft" class="anchor"></a><code><span class="keyword">let</span> bifoldLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Bifoldable">Bifoldable</a>.t<span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dt class="spec value" id="val-bifoldRight"><a href="#val-bifoldRight" class="anchor"></a><code><span class="keyword">let</span> bifoldRight: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Bifoldable">Bifoldable</a>.t<span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary></details></div></div></div><dl><dt class="spec module" id="module-WithError"><a href="#module-WithError" class="anchor"></a><code><span class="keyword">module</span> <a href="WithError">WithError</a>:  (<a href="WithError#argument-1-E">E</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></dt><dd><p>Because Result is a bi-functor, we need to capture the error type in order to implement many of the single-type-parameter typeclasses. Doing it like this allows us to unlock a bunch of stuff at once using a single module functor.</p></dd></dl></div></body></html>