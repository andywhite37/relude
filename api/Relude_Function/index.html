<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Function (api.Relude_Function)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Function</nav><h1>Module <code>Relude_Function</code></h1><p><code>Relude.Function</code> contains many core functions like <code>identity</code>, <code>flip</code>, <code>compose</code>, <code>andThen</code>, and some of the associated infix operators like <code>&lt;&lt;</code> (<code>compose</code>) and <code>&gt;&gt;</code> (<code>andThen</code>).</p><p>It also defines some typeclass instances like <code>Functor</code>, <code>Apply</code>, <code>Monad</code>, etc. for the <code>'r =&gt; 'a</code> function type.</p></header><dl><dt class="spec value" id="val-identity"><a href="#val-identity" class="anchor"></a><code><span class="keyword">let</span> identity: a. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>identity(x)</code> returns <code>x</code>. This is useful when you need to supply a function but don’t want to transform any values.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">let</span> id: a. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>id</code> is a synonym for <code>identity</code>.</p></dd></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">let</span> const: a b. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>const(x, y)</code> returns <code>x</code>.</p><pre><code class="ml">const(3, &quot;ignore&quot;) == 3;
const(&quot;keep&quot;, -1) == &quot;keep&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>flip(f, a, b)</code> has a two-parameter function <code>f()</code> as its first parameter. It calls <code>f(b, a)</code>, thus “flipping“ the arguments to <code>f()</code>.</p><pre><code class="ml">let formula = (x, y) =&gt; {x + 2 * y};
formula(3, 5) == 13;
flip(formula, 5, 3) == 13;</code></pre></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c. <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>compose(f, g, a)</code> is the equivalent of <code>f(g(a))</code>.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
compose(square, double, 3) == 36;
compose(double, square, 3) == 18;</code></pre></dd></dl><dl><dt class="spec value" id="val-flipCompose"><a href="#val-flipCompose" class="anchor"></a><code><span class="keyword">let</span> flipCompose: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>flipCompose(f, g, a)</code> is the equivalent of <code>g(f(a))</code>.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
flipCompose(square, double, 3) == 18;
flipCompose(double, square, 3) == 36;</code></pre></dd></dl><dl><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>andThen</code> is a synonym for <code>flipCompose</code></p><p>You can use this synonym with the “pipe first“ operator:</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
let addFive = (x) =&gt; {x + 5};

let formula = square -&gt; andThen(double) -&gt; andThen(addFive);
formula(3);</code></pre></dd></dl><dl><dt class="spec value" id="val-curry2"><a href="#val-curry2" class="anchor"></a><code><span class="keyword">let</span> curry2: a b c. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>Converts a function that takes a tuple 2 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry3"><a href="#val-curry3" class="anchor"></a><code><span class="keyword">let</span> curry3: a b c d. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>;</code></dt><dd><p>Converts a function that takes a tuple-3 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry4"><a href="#val-curry4" class="anchor"></a><code><span class="keyword">let</span> curry4: a b c d e. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>;</code></dt><dd><p>Converts a function that takes a tuple-4 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-curry5"><a href="#val-curry5" class="anchor"></a><code><span class="keyword">let</span> curry5: a b c d e f. <span>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>;</code></dt><dd><p>Converts a function that takes a tuple-5 as an argument to a normal curried function.</p></dd></dl><dl><dt class="spec value" id="val-uncurry2"><a href="#val-uncurry2" class="anchor"></a><code><span class="keyword">let</span> uncurry2: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p>Converts a normal curried function of two arguments to a function that takes a tuple-2 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry3"><a href="#val-uncurry3" class="anchor"></a><code><span class="keyword">let</span> uncurry3: a b c d. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span class="type-var">'d</span>;</code></dt><dd><p>Converts a normal curried function of 3 arguments to a function that takes a tuple-3 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry4"><a href="#val-uncurry4" class="anchor"></a><code><span class="keyword">let</span> uncurry4: a b c d e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span class="type-var">'e</span>;</code></dt><dd><p>Converts a normal curried function of 4 arguments to a function that takes a tuple-4 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-uncurry5"><a href="#val-uncurry5" class="anchor"></a><code><span class="keyword">let</span> uncurry5: a b c d e f. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'f</span>;</code></dt><dd><p>Converts a normal curried function of 5 arguments to a function that takes a tuple-5 as an argument.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b r. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p><code>map</code> is a synonym for <code>compose</code> and is the equivalent of <code>f(g(a))</code>.</p><pre><code class="ml">let square = (x) =&gt; {x * x};
let double = (x) =&gt; {2 * x};
map(square, double, 3) == 36;
map(double, square, 3) == 18;</code></pre></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b r. <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In <code>apply(hof, f, a)</code>, <code>hof</code> is a higher-order function that takes one argument and returns a new function that also takes one argument.</p><p>The result of <code>apply()</code> is equivalent to:</p><pre><code class="ml">let g = hof(a);
g(f(a))</code></pre><pre><code class="ml">// This is the higher-order function
let showResult = (n) =&gt; {
  (x: float) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

apply(showResult, cube, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a r. <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>pure</code> is a synonym for <code>const</code></p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b r. <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In <code>bind(f, hof, a)</code>, <code>hof</code> is a higher-order function that takes one argument and returns a new function that also takes one argument.</p><p>The result of <code>bind()</code> is equivalent to:</p><pre><code class="ml">let g = hof(f(a));
g(a)</code></pre><pre><code class="ml">// This is the higher-order function
let showResult = (x) =&gt; {
  (n: int) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

bind(cube, showResult, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b r. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In <code>flatMap(hof, f, a)</code>, <code>hof</code> is a higher-order function that takes one argument and returns a new function that also takes one argument. It is the same as <code>bind</code>, but with the first two arguments in reverse order.</p><pre><code class="ml">// This is the higher-order function
let showResult = (x) =&gt; {
  (n: int) =&gt; {&quot;input &quot; ++ string_of_int(n)
    ++ &quot; yields &quot; ++ Js.Float.toString(x)
  }
};

let cube = (x) =&gt; { float_of_int(x * x * x) };

flatMap(showResult, cube, 5) == &quot;input 5 yields 125&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-memoize0"><a href="#val-memoize0" class="anchor"></a><code><span class="keyword">let</span> memoize0: <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p><code>memoize0</code> takes a <code>unit =&gt; 'a</code> function and returns a new function which once called, will store the result produced and return that cached result for each successive call.</p></dd></dl><dl><dt class="spec value" id="val-memoize1"><a href="#val-memoize1" class="anchor"></a><code><span class="keyword">let</span> memoize1: <span>makeKey:<span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span></span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p><code>memoize1</code> takes a <code>'a =&gt; 'b</code> function and returns a new <code>'a =&gt; 'b</code> function which once called, stores the result produced by the given function in a closure-based cache, using a cache key created by the function <code>makeKey</code></p><p>All successive calls to the function for input values that resolve to the same cache key will return the cached result.</p></dd></dl><dl><dt class="spec value" id="val-before"><a href="#val-before" class="anchor"></a><code><span class="keyword">let</span> before: <span>times:int</span> <span>=&gt;</span> <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>Takes a function and returns a new function which when called, will allow the first <code>times</code> calls to invoke the given function, and any successive calls will be suppressed and the last result will be returned.</p></dd></dl><dl><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">let</span> after: <span>times:int</span> <span>=&gt;</span> <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>Takes a function and returns a new function that when called, will suppress the first <code>times</code> invocations.</p></dd></dl><dl><dt class="spec value" id="val-once"><a href="#val-once" class="anchor"></a><code><span class="keyword">let</span> once: <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> unit <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>Takes a function and returns a new function which will invoke the given function once, and any successive calls will be suppressed, returning the value of the first call.</p></dd></dl><dl><dt class="spec value" id="val-wrap"><a href="#val-wrap" class="anchor"></a><code><span class="keyword">let</span> wrap: <span>before:<span>(<span class="type-var">'i</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span></span> <span>=&gt;</span> <span>after:<span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'o</span>)</span></span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'i</span> <span>=&gt;</span> <span class="type-var">'o</span>;</code></dt><dd><p>Takes a function from <code>'a =&gt; 'b</code> and a function from <code>'i =&gt; 'a</code> to modify the input, and a function <code>'b =&gt; 'o</code> to modify the output, and returns a new function <code>'i =&gt; 'o</code></p></dd></dl><dl><dt class="spec value" id="val-negate"><a href="#val-negate" class="anchor"></a><code><span class="keyword">let</span> negate: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool;</code></dt><dd><p>Takes a predicate function, and returns a new predicate function which negates the given predicate.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix">Infix</a>: { ... };</code></dt><dd><p>The <code>Infix</code> submodule provides two infix operators for function composition.</p></dd></dl><div class="spec module" id="module-WithArgument"><a href="#module-WithArgument" class="anchor"></a><code><span class="keyword">module</span> <a href="WithArgument">WithArgument</a>:  (<a href="WithArgument#argument-1-R">R</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></div></div></body></html>