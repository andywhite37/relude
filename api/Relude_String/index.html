<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_String (api.Relude_String)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_String</nav><h1>Module <code>Relude_String</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code>;</dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: string;</code></dt><dd><p><code>String.empty</code> is the empty string value <code>&quot;&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: string <span>=&gt;</span> int;</code></dt><dd><p><code>String.length</code> returns the length of the string. Since this function calls the JavaScript <code>String.length</code> function, it works properly with Unicode characters.</p><pre><code class="ml">String.length(&quot;example&quot;) == 7;
String.length({js|Glück|js}) == 5;
String.length({js|대한민국|js}) == 4;</code></pre></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p><code>String.isEmpty</code> returns <code>true</code> if the provided string is the empty string <code>&quot;&quot;</code>, and returns <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isNonEmpty"><a href="#val-isNonEmpty" class="anchor"></a><code><span class="keyword">let</span> isNonEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p><code>isNotEmpty(str)</code> returns <code>true</code> if <code>str</code> is not the empty string <code>&quot;&quot;</code>; <code>false</code> if it is empty.</p></dd></dl><dl><dt class="spec value" id="val-isNotEmpty"><a href="#val-isNotEmpty" class="anchor"></a><code><span class="keyword">let</span> isNotEmpty: string <span>=&gt;</span> bool;</code></dt><dd><p>Alias for isNonEmpty</p></dd></dl><dl><dt class="spec value" id="val-toNonEmpty"><a href="#val-toNonEmpty" class="anchor"></a><code><span class="keyword">let</span> toNonEmpty: string <span>=&gt;</span> option(string);</code></dt><dd><p><code>toNonEmpty(str)</code> returns <code>Some(str)</code> if <code>str</code> is not the empty string <code>&quot;&quot;</code>. It returns <code>None</code> if <code>str</code> is the empty string.</p><pre><code class="ml">toNonEmpty(&quot;abc&quot;) == Some(&quot;abc&quot;);
toNonEmpty(&quot;&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">let</span> trim: string <span>=&gt;</span> string;</code></dt><dd><p><code>trim(str)</code> returns a new string with leading and trailing whitespace (blank, tab, newline, non-breaking space and others as described in &lt;https://www.ecma-international.org/ecma-262/5.1/#sec-7.2&gt;) removed from <code>s</code>.</p><pre><code class="ml">trim(&quot;  abc  &quot;) == &quot;abc&quot;;
trim(&quot;  abc def  &quot;) == &quot;abc def&quot;;
trim({js|\n\u00a0 \t abc \f\r \t|js}) == &quot;abc&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-isWhitespace"><a href="#val-isWhitespace" class="anchor"></a><code><span class="keyword">let</span> isWhitespace: string <span>=&gt;</span> bool;</code></dt><dd><p><code>isWhitespace(str)</code> returns true if the string consists entirely of whitespace characters as described in &lt;https://www.ecma-international.org/ecma-262/5.1/#sec-7.2&gt;</p><pre><code class="ml">isWhitespace(&quot; \n \t \r  &quot;) == true;
isWhitespace(&quot; \n \t X \r &quot;) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-isNonWhitespace"><a href="#val-isNonWhitespace" class="anchor"></a><code><span class="keyword">let</span> isNonWhitespace: string <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if the string contains any non-whitespace characters</p></dd></dl><dl><dt class="spec value" id="val-toNonWhitespace"><a href="#val-toNonWhitespace" class="anchor"></a><code><span class="keyword">let</span> toNonWhitespace: string <span>=&gt;</span> option(string);</code></dt><dd><p><code>toNonWhiteSpace(str)</code> returns <code>Some(str)</code> if <code>str</code> has any non-whitespace characters in it. The function returns <code>None</code> if <code>str</code> consists entirely of whitespace.</p><pre><code class="ml">toNonWhitespace(&quot;\n\t abc \t\r&quot;) == Some(&quot;\n\t abc \t\r&quot;);
toNonWhitespace(&quot;\t\n  \r&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">let</span> concat: string <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>concat(str1, str2)</code> concatenate the two strings, returning a new string.</p><pre><code class="ml">concat(&quot;door&quot;, &quot;bell&quot;) == &quot;doorbell&quot;;
concat(&quot;&quot;, &quot;next&quot;) == &quot;next&quot;;
concat(&quot;first&quot;, &quot;&quot;) == &quot;first&quot;;</code></pre></dd></dl><div class="spec module" id="module-Semigroup"><a href="#module-Semigroup" class="anchor"></a><code><span class="keyword">module</span> Semigroup: BsBastet.Interface.SEMIGROUP <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Semigroup">Semigroup</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-concatNamed"><a href="#val-concatNamed" class="anchor"></a><code><span class="keyword">let</span> concatNamed: <span>prefix:<a href="#module-Semigroup">Semigroup</a>.t</span> <span>=&gt;</span> <a href="#module-Semigroup">Semigroup</a>.t <span>=&gt;</span> <a href="#module-Semigroup">Semigroup</a>.t;</code></dt></dl></details></div></div></div><div class="spec module" id="module-Monoid"><a href="#module-Monoid" class="anchor"></a><code><span class="keyword">module</span> Monoid: BsBastet.Interface.MONOID <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Monoid">Monoid</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsMonoidExtensions"><a href="#module-BsMonoidExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsMonoidExtensions">BsMonoidExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">let</span> guard: bool <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t;</code></dt><dt class="spec value" id="val-power"><a href="#val-power" class="anchor"></a><code><span class="keyword">let</span> power: <a href="#module-Monoid">Monoid</a>.t <span>=&gt;</span> int <span>=&gt;</span> <a href="#module-Monoid">Monoid</a>.t;</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-concatArray"><a href="#val-concatArray" class="anchor"></a><code><span class="keyword">let</span> concatArray: array(string) <span>=&gt;</span> string;</code></dt><dd><p><code>concatArray(xs)</code> returns a new string that is the result of concatenating all the strings in <code>xs</code>.</p><pre><code class="ml">concatArray([|&quot;cat&quot;, &quot;en&quot;, &quot;ate&quot;|]) == &quot;catenate&quot;;
concatArray([|&quot;chair&quot;, &quot;&quot;, &quot;person&quot;|]) == &quot;chairperson&quot;;
concatArray([| |]) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-concatList"><a href="#val-concatList" class="anchor"></a><code><span class="keyword">let</span> concatList: list(string) <span>=&gt;</span> string;</code></dt><dd><p><code>String.concatList</code> is the <code>list</code> version of <a href="#val-concatArray"><code>concatArray</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: <span class="type-var">'a</span> <span>=&gt;</span> string;</code></dt><dd><p><code>make(x)</code> converts <code>x</code> to a string. If <code>x</code> is not a primitive type such as integer, float, string, or boolean, the result will reflect ReasonML’s internal format for that data type.</p><pre><code class="ml">make(32.5) == &quot;32.5&quot;;
make(1.0e3) == &quot;1000&quot;;
make(true) == &quot;true&quot;;
make(&quot;already a string&quot;) == &quot;already a string&quot;;
make([1, 2, 3, 4]) == &quot;1,2,3,4,0&quot;;
make([|1, 2, 3, 4|]) == &quot;1,2,3,4&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-makeWithIndex"><a href="#val-makeWithIndex" class="anchor"></a><code><span class="keyword">let</span> makeWithIndex: int <span>=&gt;</span> <span>(int <span>=&gt;</span> string)</span> <span>=&gt;</span> string;</code></dt><dd><p><code>makeWithIndex(n, f)</code> returns a string that is the result of concatenating <code>f(0)</code>, <code>f(1)</code>, ... <code>f(n - 1)</code>, where function <code>f()</code> takes an integer argument and returns a string.</p><pre><code class="ml">let squareChar = (n) =&gt; {fromCharCode(97 + n * n)};
makeWithIndex(4, squareChar) == &quot;abej&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">let</span> repeat: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>repeat(n, str)</code> returns a string consisting of <code>n</code> repetitions of <code>str</code>.</p><pre><code class="ml">repeat(3, &quot;ha&quot;) == &quot;hahaha&quot;;
repeat(0, &quot;ha&quot;) == &quot;&quot;;
repeat(-1, &quot;ha&quot;) == &quot;&quot;;
repeat(3, &quot;&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-toUpperCase"><a href="#val-toUpperCase" class="anchor"></a><code><span class="keyword">let</span> toUpperCase: string <span>=&gt;</span> string;</code></dt><dd><p><code>toUpperCase(str)</code> converts <code>str</code> to upper case using the locale-insensitive case mappings in the Unicode Character Database. Notice that the conversion can expand the number of letters in the result; for example, the German <code>&quot;ß&quot;</code> capitalizes to two <code>&quot;S&quot;</code>es in a row.</p><pre><code class="ml">toUpperCase(&quot;abc&quot;) == &quot;ABC&quot;;
toUpperCase({js|Straße|js}) == {js|STRASSE|js};
toUpperCase({js|σπ|js}) == {js|ΣΠ|js};
toUpperCase({js|πς|js}) == {js|ΠΣ|js}; // sigma in final position</code></pre></dd></dl><dl><dt class="spec value" id="val-toLowerCase"><a href="#val-toLowerCase" class="anchor"></a><code><span class="keyword">let</span> toLowerCase: string <span>=&gt;</span> string;</code></dt><dd><p><code>toLowerCase(str)</code> converts <code>str</code> to lower case using the locale-insensitive case mappings in the Unicode Character Database.</p><p>Note that the conversion might not lessen the number of letters in the result; for example, in some German words, two <code>&quot;S&quot;</code>es in a row can convert to the single lowercase glyph <code>ß</code>, but <code>toLowerCase()</code> will not do this transformation.</p><pre><code class="ml">toLowerCase(&quot;ABC&quot;) == &quot;abc&quot;;
toLowerCase({js|STRASSE|js}) == {js|strasse|js};
toLowerCase({js|ΣΠ|js}) == {js|σπ|js};
toLowerCase({js|ΠΣ|js}) == {js|πς|js}; // sigma in final position</code></pre></dd></dl><dl><dt class="spec value" id="val-fromCharCode"><a href="#val-fromCharCode" class="anchor"></a><code><span class="keyword">let</span> fromCharCode: int <span>=&gt;</span> string;</code></dt><dd><p><code>fromCharCode(n)</code> creates a string containing the character corresponding to that number; n ranges from 0 to 65535. If out of range, the lower 16 bits of the value are used.</p><p>Thus, <code>fromCharCode(0x1F63A)</code> gives the same result as <code>fromCharCode(0xF63A)</code>.</p><pre><code class="ml">fromCharCode(65) == &quot;A&quot;;
fromCharCode(0x0920) == {js|ठ|js};
fromCharCode(0x3c8) == {js|ψ|js};
fromCharCode(-64568) == {js|ψ|js};</code></pre></dd></dl><dl><dt class="spec value" id="val-charCodeAt"><a href="#val-charCodeAt" class="anchor"></a><code><span class="keyword">let</span> charCodeAt: int <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p><code>charCodeAt(n, str)</code> returns (optionally) the numeric character code at the given 0-based position in a string. If the provided position is out of the range of the size of the string (too high or negative), <code>None</code> is returned.</p><pre><code class="ml">charCodeAt(0, &quot;abc&quot;) == Some(97);
charCodeAt(-1, &quot;abc&quot;) == None;
charCodeAt(0, &quot;&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAt"><a href="#val-charAt" class="anchor"></a><code><span class="keyword">let</span> charAt: int <span>=&gt;</span> string <span>=&gt;</span> option(string);</code></dt><dd><p><code>charAt(n, str)</code> returns <code>Some(chStr)</code>, where <code>chStr</code> is a string consisting of the character at location <code>n</code> in the string. The first character in a string has position zero.</p><p>If <code>n</code> is out of bounds, <code>charAt()</code> returns <code>None</code>.</p><pre><code class="ml">charAt(0, &quot;abc&quot;) == Some(&quot;a&quot;);
charAt(2, &quot;abc&quot;) == Some(&quot;c&quot;);
charAt(1, {js|대한민국|js}) == Some({js|한|js});
charAt(-1, &quot;abc&quot;) == None;
charAt(3, &quot;abc&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtOrEmpty"><a href="#val-charAtOrEmpty" class="anchor"></a><code><span class="keyword">let</span> charAtOrEmpty: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>charAtOrEmpty(n, str)</code> returns the string containing the character at the given index or the empty string if the index is out of range.</p><pre><code class="ml">charAtOrEmpty(0, &quot;abc&quot;) == &quot;a&quot;;
charAtOrEmpty(0, &quot;&quot;) == &quot;&quot;;
charAtOrEmpty(2, &quot;a&quot;) == &quot;&quot;;
charAtOrEmpty(-1, &quot;abc&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtNullable"><a href="#val-charAtNullable" class="anchor"></a><code><span class="keyword">let</span> charAtNullable: int <span>=&gt;</span> string <span>=&gt;</span> Js.Nullable.t(string);</code></dt><dd><p><code>charAtNullable(n, str)</code> returns <code>Js.Nullable.return(chStr)</code>, where <code>chStr</code> is a string consisting of the character at location <code>n</code> in the string. The first character in a string has position zero.</p><p>If <code>n</code> is out of bounds, <code>charAtNullable()</code> returns <code>Js.Nullable.undefined</code>.</p><pre><code class="ml">charAtNullable(0, &quot;abc&quot;) == Js.Nullable.return(&quot;a&quot;);
charAtNullable(2, &quot;abc&quot;) == Js.Nullable.return(&quot;c&quot;);
charAtNullable(1, {js|대한민국|js}) == Js.Nullable.return({js|한|js});
charAtNullable(-1, &quot;abc&quot;) == Js.Nullable.undefined;
charAtNullable(3, &quot;abc&quot;) == Js.Nullable.undefined;</code></pre></dd></dl><dl><dt class="spec value" id="val-charAtOrThrow"><a href="#val-charAtOrThrow" class="anchor"></a><code><span class="keyword">let</span> charAtOrThrow: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>charAtOrThrow(n, str)</code> returns a string consisting of the character at location <code>n</code> in the string. The first character in a string has position zero.</p><p>If <code>n</code> is out of bounds, <code>charAtOrThrow()</code> throws a <code>RangeError</code>.</p><pre><code class="ml">charAtOrThrow(0, &quot;abc&quot;) == &quot;a&quot;;
charAtOrThrow(2, &quot;abc&quot;) == &quot;c&quot;;
charAtOrThrow(1, {js|대한민국|js}) == {js|한|js};
try (charAtOrThrow(-1, &quot;abc&quot;)) {
  | Js.Exn.Error(_) =&gt; &quot;Invalid index&quot;
} == &quot;Invalid index&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: string <span>=&gt;</span> list(string);</code></dt><dd><p><code>toList(str)</code> creates a list with one character of <code>str</code> per element.</p><pre><code class="ml">toList(&quot;abc&quot;) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
toList({js|日本|js}) == [{js|日|js}, {js|本|js}];
toList(&quot;&quot;) == [];</code></pre></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: string <span>=&gt;</span> array(string);</code></dt><dd><p><code>toArray(str)</code> creates an array with one character of <code>str</code> per element.</p><pre><code class="ml">toArray(&quot;abc&quot;) == [|&quot;a&quot;, &quot;b&quot;, &quot;c&quot;|];
toArray({js|日本|js}) == [|{js|日|js}, {js|本|js}|];
toArray(&quot;&quot;) == [| |];</code></pre></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In <code>foldLeft(f, init, str)</code>, <code>f()</code> is a function that takes an accumulated value and a string as its arguments. <code>foldLeft</code> starts with <code>init</code> as the value of an accumulator. It then calls <code>f</code> repeatedly with each character in the string, moving from left to right, with the result <code>f(accumulator, chStr)</code> becoming the new value of the accumulator. When all characters have been processed, the return value is the value of the accumulator.</p><pre><code class="ml">let valueOfChar = (chStr) =&gt; {int_of_float(Js.String.charCodeAt(0, chStr))};
foldLeft( (acc, chStr) =&gt; {acc + valueOfChar(chStr)}, 0, &quot;abc&quot;) == 97 + 98 + 99;
foldLeft( (acc, chStr) =&gt; {acc ++ &quot;-&quot; ++ chStr}, &quot;&quot;, &quot;abc&quot;) == &quot;-a-b-c&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-foldRight"><a href="#val-foldRight" class="anchor"></a><code><span class="keyword">let</span> foldRight: <span>(string <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> string <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>In <code>foldRight(f, init, str)</code>, <code>f()</code> is a function that takes a string and an accumulator as its arguments. <code>foldRight</code> starts with <code>init</code> as the value of an accumulator. It then calls <code>f</code> repeatedly with each character in the string, moving from right to left, with the result <code>f(chStr, accumulator)</code> becoming the new value of the accumulator. When all characters have been processed, the return value is the value of the accumulator.</p><pre><code class="ml">let valueOfChar = (chStr) =&gt; {int_of_float(Js.String.charCodeAt(0, chStr))};
foldRight( (chStr, acc) =&gt; {acc + valueOfChar(chStr)}, 0, &quot;abc&quot;) == 97 + 98 + 99;
foldRight( (chStr, acc) =&gt; {acc ++ &quot;-&quot; ++ chStr}, &quot;&quot;, &quot;abc&quot;) == &quot;-c-b-a&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">let</span> show: string <span>=&gt;</span> string;</code></dt><dd><p>Show function for string (identity)</p></dd></dl><dl><dt class="spec module" id="module-Show"><a href="#module-Show" class="anchor"></a><code><span class="keyword">module</span> Show: BsBastet.Interface.SHOW <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Show">Show</a>.t = string;</code></dt><dd><p>SHOW module for string</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">let</span> eq: string <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p><code>eq(s1, s2)</code> is a synonym for <code>s1 == s2</code></p></dd></dl><div class="spec module" id="module-Eq"><a href="#module-Eq" class="anchor"></a><code><span class="keyword">module</span> Eq: BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Eq">Eq</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-eqWithConversion"><a href="#val-eqWithConversion" class="anchor"></a><code><span class="keyword">let</span> eqWithConversion: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Eq">Eq</a>.t)</span> <span>=&gt;</span> Relude_Eq.eq(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-notEq"><a href="#val-notEq" class="anchor"></a><code><span class="keyword">let</span> notEq: Relude_Eq.eq(<a href="#module-Eq">Eq</a>.t);</code></dt><dt class="spec value" id="val-eqInverted"><a href="#val-eqInverted" class="anchor"></a><code><span class="keyword">let</span> eqInverted: Relude_Eq.eq(<a href="#module-Eq">Eq</a>.t);</code></dt></dl><div class="spec module" id="module-EqInverted"><a href="#module-EqInverted" class="anchor"></a><code><span class="keyword">module</span> <a href="EqInverted">EqInverted</a>: { ... };</code></div><div class="spec module-type" id="module-type-EQ_BY_F"><a href="#module-type-EQ_BY_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-EQ_BY_F">EQ_BY_F</a> =  (<a href="module-type-EQ_BY_F/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-EqBy"><a href="#module-EqBy" class="anchor"></a><code><span class="keyword">module</span> <a href="EqBy">EqBy</a>:  (<a href="EqBy/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div></details></div></div></div><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">let</span> compare: BsBastet.String.Ord.t <span>=&gt;</span> BsBastet.String.Ord.t <span>=&gt;</span> BsBastet.Interface.ordering;</code></dt><dd><p>Compares two strings</p></dd></dl><div class="spec module" id="module-Ord"><a href="#module-Ord" class="anchor"></a><code><span class="keyword">module</span> Ord: BsBastet.Interface.ORD <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Ord">Ord</a>.t = string;</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-compareWithConversion"><a href="#val-compareWithConversion" class="anchor"></a><code><span class="keyword">let</span> compareWithConversion: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t)</span> <span>=&gt;</span> Relude_Ord.compare(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-compareReversed"><a href="#val-compareReversed" class="anchor"></a><code><span class="keyword">let</span> compareReversed: Relude_Ord.compare(<a href="#module-Ord">Ord</a>.t);</code></dt></dl><div class="spec module" id="module-OrdReversed"><a href="#module-OrdReversed" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdReversed">OrdReversed</a>: { ... };</code></div><dl><dt class="spec value" id="val-compareAsInt"><a href="#val-compareAsInt" class="anchor"></a><code><span class="keyword">let</span> compareAsInt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-lessThan"><a href="#val-lessThan" class="anchor"></a><code><span class="keyword">let</span> lessThan: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lt"><a href="#val-lt" class="anchor"></a><code><span class="keyword">let</span> lt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lessThanOrEq"><a href="#val-lessThanOrEq" class="anchor"></a><code><span class="keyword">let</span> lessThanOrEq: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-lte"><a href="#val-lte" class="anchor"></a><code><span class="keyword">let</span> lte: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-greaterThan"><a href="#val-greaterThan" class="anchor"></a><code><span class="keyword">let</span> greaterThan: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-gt"><a href="#val-gt" class="anchor"></a><code><span class="keyword">let</span> gt: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-greaterThanOrEq"><a href="#val-greaterThanOrEq" class="anchor"></a><code><span class="keyword">let</span> greaterThanOrEq: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-gte"><a href="#val-gte" class="anchor"></a><code><span class="keyword">let</span> gte: <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-clamp"><a href="#val-clamp" class="anchor"></a><code><span class="keyword">let</span> clamp: <span>min:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <span>max:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t;</code></dt><dt class="spec value" id="val-between"><a href="#val-between" class="anchor"></a><code><span class="keyword">let</span> between: <span>min:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <span>max:<a href="#module-Ord">Ord</a>.t</span> <span>=&gt;</span> <a href="#module-Ord">Ord</a>.t <span>=&gt;</span> bool;</code></dt></dl><div class="spec module" id="module-OrdRingExtensions"><a href="#module-OrdRingExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdRingExtensions">OrdRingExtensions</a>:  (<a href="OrdRingExtensions/argument-1-R">R</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-OrdNamed"><a href="#module-OrdNamed" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdNamed">OrdNamed</a>: { ... };</code></div><div class="spec module-type" id="module-type-ORD_BY_F"><a href="#module-type-ORD_BY_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ORD_BY_F">ORD_BY_F</a> =  (<a href="module-type-ORD_BY_F/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-OrdBy"><a href="#module-OrdBy" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdBy">OrdBy</a>:  (<a href="OrdBy/argument-1-A">A</a>: { ... }) <span>=&gt;</span> { ... };</code></div></details></div></div></div><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map">Map</a>: { ... };</code></dt><dd><p>Map module with a string key</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set">Set</a>: { ... };</code></dt><dd><p>Set module for strings</p></dd></dl><dl><dt class="spec value" id="val-endsWith"><a href="#val-endsWith" class="anchor"></a><code><span class="keyword">let</span> endsWith: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p><code>endsWith(~search, input)</code> returns <code>true</code> if <code>input</code> ends with the characters in <code>target</code>; <code>false</code> otherwise.</p><pre><code class="ml">endsWith(~search=&quot;ing&quot;, &quot;programming&quot;) == true;
endsWith(~search=&quot;ing&quot;, &quot;program&quot;) == false;
endsWith(~search=&quot;ing&quot;, &quot;in&quot;) == false;
endsWith(~search=&quot;&quot;, &quot;everything&quot;) == true;</code></pre></dd></dl><dl><dt class="spec value" id="val-startsWith"><a href="#val-startsWith" class="anchor"></a><code><span class="keyword">let</span> startsWith: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p><code>startsWith(~search, input)</code> returns <code>true</code> if <code>input</code> starts with the characters in <code>search</code>; <code>false</code> otherwise.</p><pre><code class="ml">startsWith(~search=&quot;pro&quot;, &quot;programming&quot;) == true;
startsWith(~search=&quot;pre&quot;, &quot;program&quot;) == false;
startsWith(~search=&quot;pre&quot;, &quot;pr&quot;) == false;
startsWith(~search=&quot;&quot;, &quot;everything&quot;) == true;</code></pre></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> bool;</code></dt><dd><p><code>contains(~search, input)</code> returns <code>true</code> if <code>search</code> appears anywhere in <code>input</code>; <code>false</code> otherwise.</p><pre><code class="ml">contains(~search=&quot;cat&quot;, &quot;catalog&quot;) == true;
contains(~search=&quot;cat&quot;, &quot;scatter&quot;) == true;
contains(~search=&quot;log&quot;, &quot;catalog&quot;) == true;
contains(~search=&quot;ato&quot;, &quot;fraction&quot;) == false;</code></pre></dd></dl><dl><dt class="spec value" id="val-indexOf"><a href="#val-indexOf" class="anchor"></a><code><span class="keyword">let</span> indexOf: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p><code>indexOf(test, str)</code> returns <code>Some(n)</code>, where <code>n</code> is the starting position of the first occurrence of <code>test</code> within <code>str</code>. If <code>test</code> is not in <code>str</code>, the return value is <code>None</code>.</p><pre><code class="ml">indexOf(&quot;cat&quot;, &quot;catalog&quot;) == Some(0);
indexOf(&quot;cat&quot;, &quot;scatter&quot;) == Some(1);
indexOf(&quot;in&quot;, &quot;stringing&quot;) == Some(3);
indexOf(&quot;xyz&quot;, &quot;blah&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-lastIndexOf"><a href="#val-lastIndexOf" class="anchor"></a><code><span class="keyword">let</span> lastIndexOf: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> option(int);</code></dt><dd><p><code>lastIndexOf(test, str)</code> returns <code>Some(n)</code>, where <code>n</code> is the starting position of the last occurrence of <code>test</code> within <code>str</code>. If <code>test</code> is not in <code>str</code>, the return value is <code>false</code>.</p><pre><code class="ml">lastIndexOf(&quot;cat&quot;, &quot;catalog&quot;) == Some(0);
lastIndexOf(&quot;cat&quot;, &quot;scatter&quot;) == Some(1);
lastIndexOf(&quot;in&quot;, &quot;stringing&quot;) == Some(6);
lastIndexOf(&quot;xyz&quot;, &quot;blah&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span class="keyword">let</span> slice: int <span>=&gt;</span> int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>slice(n1, n2, str)</code> returns the substring of <code>str</code> starting at character <code>n1</code> up to but not including <code>n2</code>.</p><p>If either <code>n1</code> or <code>n2</code> is negative, then it is evaluated as <code>length(str) - n1</code> (or <code>length(str) - n2</code>).</p><p>If <code>n2</code> is greater than the length of <code>str</code>, then it is treated as <code>length(str)</code>.</p><p>If <code>n1</code> is greater than <code>n2</code>, <code>slice()</code> returns the empty string.</p><pre><code class="ml">slice(2, 5, &quot;abcdefg&quot;) == &quot;cde&quot;;
slice(2, 9, &quot;abcdefg&quot;) == &quot;cdefg&quot;;
slice(-4, -2, &quot;abcdefg&quot;) == &quot;de&quot;;
slice(5, 1, &quot;abcdefg&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-sliceToEnd"><a href="#val-sliceToEnd" class="anchor"></a><code><span class="keyword">let</span> sliceToEnd: int <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>sliceToEnd(n, str)</code> returns the substring of <code>str</code> starting at character <code>n</code> to the end of the string</p><p>If <code>n</code> is negative, then it is evaluated as <code>length(str) - n</code>.</p><p>If <code>n</code> is greater than the length of <code>str</code>, then <code>sliceToEnd()</code> returns the empty string.</p><pre><code class="ml">sliceToEnd(4, &quot;abcdefg&quot;) == &quot;efg&quot;;
sliceToEnd(-2, &quot;abcdefg&quot;) == &quot;fg&quot;;
sliceToEnd(7, &quot;abcdefg&quot;) == &quot;&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-splitArray"><a href="#val-splitArray" class="anchor"></a><code><span class="keyword">let</span> splitArray: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> array(string);</code></dt><dd><p><code>splitArray(delimiter, str)</code> splits the given <code>str</code> at every occurrence of <code>delimiter</code> and returns an array of the resulting substrings.</p><pre><code class="ml">splitArray(&quot;-&quot;, &quot;2019-01-02&quot;) == [|&quot;2019&quot;, &quot;01&quot;, &quot;02&quot;|];
splitArray(&quot;,&quot;, &quot;a,b,,c&quot;) == [|&quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;|];
splitArray(&quot;::&quot;, &quot;good::better::best&quot;) == [|&quot;good&quot;, &quot;better&quot;, &quot;best&quot;|];
splitArray(&quot;;&quot;, &quot;has-no-delimiter&quot;) == [|&quot;has-no-delimiter&quot;|];</code></pre></dd></dl><dl><dt class="spec value" id="val-splitAsArray"><a href="#val-splitAsArray" class="anchor"></a><code><span class="keyword">let</span> splitAsArray: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> array(string);</code></dt><dd><p><code>String.splitAsArray</code> is an alias for <a href="#val-splitArray"><code>splitArray</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-splitList"><a href="#val-splitList" class="anchor"></a><code><span class="keyword">let</span> splitList: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> list(string);</code></dt><dd><p><code>splitList(delimiter, str)</code> splits the given <code>str</code> at every occurrence of <code>delimiter</code> and returns a list of the resulting substrings.</p><pre><code class="ml">splitList(&quot;-&quot;, &quot;2019-01-02&quot;) == [&quot;2019&quot;, &quot;01&quot;, &quot;02&quot;];
splitList(&quot;,&quot;, &quot;a,b,,c&quot;) == [&quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;];
splitList(&quot;::&quot;, &quot;good::better::best&quot;) == [&quot;good&quot;, &quot;better&quot;, &quot;best&quot;];
splitList(&quot;;&quot;, &quot;has-no-delimiter&quot;) == [&quot;has-no-delimiter&quot;];</code></pre></dd></dl><dl><dt class="spec value" id="val-splitAsList"><a href="#val-splitAsList" class="anchor"></a><code><span class="keyword">let</span> splitAsList: <span>delimiter:string</span> <span>=&gt;</span> string <span>=&gt;</span> list(string);</code></dt><dd><p><code>String.splitAsList</code> is an alias for <a href="#val-splitList"><code>splitList</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-splitAt"><a href="#val-splitAt" class="anchor"></a><code><span class="keyword">let</span> splitAt: int <span>=&gt;</span> string <span>=&gt;</span> <span>(string, string)</span>;</code></dt><dd><p><code>splitAt(index, str)</code> splits the string at the given index, returning a tuple of the parts. If <code>index</code> is negative, it is evaluated as <code>length(str) - index</code>.</p><pre><code class="ml">splitAt(4, &quot;abcdefg&quot;) == (&quot;abcd&quot;, &quot;efg&quot;);
splitAt(0, &quot;abcdefg&quot;) == (&quot;&quot;, &quot;abcdefg&quot;);
splitAt(7, &quot;abcdefg&quot;) == (&quot;abcdefg&quot;, &quot;&quot;);
splitAt(8, &quot;abcdefg&quot;) == (&quot;abcdefg&quot;, &quot;&quot;);
splitAt(-3, &quot;abcdefg&quot;) == (&quot;abcd&quot;, &quot;efg&quot;);
splitAt(-9, &quot;abcdefg&quot;) == (&quot;&quot;, &quot;abcdefg&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-mapChars"><a href="#val-mapChars" class="anchor"></a><code><span class="keyword">let</span> mapChars: <span>(string <span>=&gt;</span> string)</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>mapChars(f, str)</code> applies the function <code>f()</code> to each character of the string, returning a new string.</p><pre><code class="ml">let duplicate = (ch) =&gt; {ch ++ ch};
mapChars(duplicate, &quot;abcde&quot;) == &quot;aabbccddee&quot;;
let capsOnly = (ch) =&gt; {(ch &gt;= &quot;A&quot; &amp;&amp; ch &lt;= &quot;Z&quot;) ? ch : &quot;&quot;};
mapChars(capsOnly, &quot;AbCdE&quot;) == &quot;ACE&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-padStart"><a href="#val-padStart" class="anchor"></a><code><span class="keyword">let</span> padStart: <span>targetLength:int</span> <span>=&gt;</span> <span>?&#8288;padWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>Pads the string to <code>targetLength</code> using <code>padWith</code> as a repeated padding on the left side of the <code>input</code> string</p></dd></dl><dl><dt class="spec value" id="val-padEnd"><a href="#val-padEnd" class="anchor"></a><code><span class="keyword">let</span> padEnd: <span>targetLength:int</span> <span>=&gt;</span> <span>?&#8288;padWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p>Pads the string to <code>targetLength</code> using <code>padWith</code> as a repeated padding on the right side of the <code>input</code> string</p></dd></dl><dl><dt class="spec value" id="val-replaceFirst"><a href="#val-replaceFirst" class="anchor"></a><code><span class="keyword">let</span> replaceFirst: <span>search:string</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>replaceFirst(target, newValue, str)</code> replaces the first occurrence of <code>target</code> with <code>newValue</code> in <code>str</code>, returning a new string.</p><pre><code class="ml">replaceFirst(&quot;in&quot;, &quot;t&quot;, &quot;the rain in spain&quot;) == &quot;the rat in spain&quot;;
replaceFirst(&quot;in&quot;, &quot;t&quot;, &quot;playground&quot;) == &quot;playground&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-replaceEach"><a href="#val-replaceEach" class="anchor"></a><code><span class="keyword">let</span> replaceEach: <span>search:string</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>replaceEach(target, newValue, str)</code>replaces each occurrence of <code>target</code> with <code>newValue</code> in <code>str</code>, returning a new string.</p><pre><code class="ml">replaceEach(&quot;in&quot;, &quot;t&quot;, &quot;the rain in spain&quot;) == &quot;the rat t spat&quot;;
replaceEach(&quot;in&quot;, &quot;t&quot;, &quot;playground&quot;) == &quot;playground&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-replaceRegex"><a href="#val-replaceRegex" class="anchor"></a><code><span class="keyword">let</span> replaceRegex: <span>search:Js.Re.t</span> <span>=&gt;</span> <span>replaceWith:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>replaceRegex(targetRe, newValue, str)</code> replaces the matched regular expression <code>targetRe</code> with <code>newValue</code> in <code>str</code>, returning a new string.</p><p>If you use parentheses to store matching substrings in your pattern (as in the last two examples), you may refer to them as <code>$1</code>, <code>$2</code> etc. in your replacement pattern.</p><pre><code class="ml">replaceRegex([%re&quot;/b[aeiou]g/&quot;], &quot;---&quot;, &quot;The big bog bug&quot;) == &quot;The --- bog bug&quot;;
replaceRegex([%re&quot;/b[aeiou]g/g&quot;], &quot;---&quot;, &quot;The big bog bug&quot;) == &quot;The --- --- ---&quot;;
replaceRegex([%re&quot;/b([aeiou])g/g&quot;], &quot;$1&quot;, &quot;The big bog bug&quot;) == &quot;The i o u&quot;;
replaceRegex([%re&quot;/(\\w+)\\s+(\\w+)/&quot;], &quot;$2, $1&quot;, &quot;Clyde Tolson&quot;) == &quot;Tolson, Clyde&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-removeFirst"><a href="#val-removeFirst" class="anchor"></a><code><span class="keyword">let</span> removeFirst: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>removeFirst(target, str)</code> returns a new string with the first occurrence of <code>target</code> removed from <code>str</code>.</p><pre><code class="ml">removeFirst(&quot;the &quot;, &quot;Paris in the the spring&quot;) == &quot;Paris in the spring&quot;;
removeFirst(&quot;the &quot;, &quot;ReasonML is cool&quot;) == &quot;ReasonML is cool&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-removeEach"><a href="#val-removeEach" class="anchor"></a><code><span class="keyword">let</span> removeEach: <span>search:string</span> <span>=&gt;</span> string <span>=&gt;</span> string;</code></dt><dd><p><code>removeEach(target, str)</code> returns a new string with every occurrence of <code>target</code> removed from <code>str</code>.</p><pre><code class="ml">removeEach(&quot;the &quot;, &quot;Paris in the the spring&quot;) == &quot;Paris in spring&quot;;
removeEach(&quot;the &quot;, &quot;ReasonML is cool&quot;) == &quot;ReasonML is cool&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-fromInt"><a href="#val-fromInt" class="anchor"></a><code><span class="keyword">let</span> fromInt: int <span>=&gt;</span> string;</code></dt><dd><p><code>fromInt(n)</code> returns <code>n</code> as a string. This function is a synonym for the built-in <code>string_of_int()</code>.</p></dd></dl><dl><dt class="spec value" id="val-toInt"><a href="#val-toInt" class="anchor"></a><code><span class="keyword">let</span> toInt: string <span>=&gt;</span> option(int);</code></dt><dd><p><code>toInt(str)</code> returns <code>Some(n)</code> if <code>str</code> is a valid string representation of the integer <code>n</code>. Otherwise, the return value is <code>None</code>.</p><pre><code class="ml">toInt(&quot;42&quot;) == Some(42);
toInt(&quot;42.3&quot;) == None;
toInt(&quot;four&quot;) == None;
toInt(&quot;&quot;) == None;</code></pre></dd></dl><dl><dt class="spec value" id="val-fromFloat"><a href="#val-fromFloat" class="anchor"></a><code><span class="keyword">let</span> fromFloat: float <span>=&gt;</span> string;</code></dt><dd><p><code>fromFloat(x)</code> converts the value to a string representation. Note that, as in the last examples, it may not be exactly the same as the representation you used when specifying <code>x</code>.</p><pre><code class="ml">fromFloat(-3.5) == &quot;-3.5&quot;;
fromFloat(6.02E23) == &quot;6.02e+23&quot;;
fromFloat(1.0e3) == &quot;1000&quot;;</code></pre></dd></dl><dl><dt class="spec value" id="val-toFloat"><a href="#val-toFloat" class="anchor"></a><code><span class="keyword">let</span> toFloat: string <span>=&gt;</span> option(float);</code></dt><dd><p><code>toFloat(str)</code> returns <code>Some(x)</code> if <code>str</code> is a valid string representation of the float value <code>x</code>. Otherwise, the return value is <code>None</code>.</p><pre><code class="ml">toFloat(&quot;42&quot;) == Some(42.0);
toFloat(&quot;42.3&quot;) == Some(42.3);
toFloat(&quot;123400000&quot;) == Some(123400000.0);
toFloat(&quot;four&quot;) == None;
toFloat(&quot;&quot;) == None;</code></pre></dd></dl></div></body></html>