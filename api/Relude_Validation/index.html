<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Validation (api.Relude_Validation)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Validation</nav><h1>Module <code>Relude_Validation</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = </code><table class="variant"><tr id="type-t.VOk" class="anchored"><td class="def constructor"><a href="#type-t.VOk" class="anchor"></a><code>| </code><code><span class="constructor">VOk</span>(<span class="type-var">'a</span>)</code></td></tr><tr id="type-t.VError" class="anchored"><td class="def constructor"><a href="#type-t.VError" class="anchor"></a><code>| </code><code><span class="constructor">VError</span>(<span class="type-var">'e</span>)</code></td></tr></table>;</dt><dd><p>Similar to result, but has an Applicative instance that collects the errors using a semigroup, rather than fail-fast semantics.</p></dd></dl><dl><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">let</span> ok: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>ok()</code> wraps a value in <code>VOk</code></p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">let</span> error: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>error(val)</code> wraps the value in a <code>VError()</code>.</p><pre><code class="ml">error(&quot;Not even&quot;) == VError(&quot;Not even&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-errorNel"><a href="#val-errorNel" class="anchor"></a><code><span class="keyword">let</span> errorNel: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>Puts an error into a NonEmptyList on the error side of the validation</p></dd></dl><dl><dt class="spec value" id="val-errorNea"><a href="#val-errorNea" class="anchor"></a><code><span class="keyword">let</span> errorNea: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e</span>))</span>;</code></dt><dd><p>Puts an error into a NonEmptyArray on the error side of the validation</p></dd></dl><dl><dt class="spec value" id="val-isOk"><a href="#val-isOk" class="anchor"></a><code><span class="keyword">let</span> isOk: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>isOk(v)</code> returns <code>true</code> if <code>v</code> is of the form <code>VOk(val)</code>; <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-isError"><a href="#val-isError" class="anchor"></a><code><span class="keyword">let</span> isError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>isError(x)</code> returns <code>true</code> if <code>x</code> is of the form <code>VError(val)</code>; <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>map(f, x)</code> returns <code>VOk(f(x))</code> if <code>x</code> is of the form <code>VOk(v)</code>. It returns <code>VError(e)</code> if <code>x</code> is of the form <code>VError(e)</code>.</p><pre><code class="ml">map((x) =&gt; {sqrt(float_of_int(x))}, VOk(4)) == VOk(2.0);
map((x) =&gt; {sqrt(float_of_int(x))}, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>tap(f, x)</code>, function <code>f()</code> returns <code>unit</code>. Thus, <code>f()</code> is used only for its side effects. If <code>x</code> is of the form <code>VOk(v)</code>, <code>tap()</code> calls <code>f(v)</code>. The <code>tap()</code> function returns the argument <code>x</code>.</p><pre><code class="ml">tap(x =&gt; Js.log(x), VOk(4)) == VOk(4); // prints 4
tap(x =&gt; Js.log(x), VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints nothing</code></pre></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p><code>mapError(f, x)</code> returns <code>VOk(v)</code> if <code>x</code> is of the form <code>VOk(v)</code>. It returns <code>VError(f(e))</code> if <code>x</code> is of the form <code>VError(e)</code>.</p><pre><code class="ml">mapError(x =&gt; &quot;Error: &quot; ++ x, VOk(4)) == VOk(4);
mapError(x =&gt; &quot;Error: &quot; ++ x, VError(&quot;bad&quot;)) == VError(&quot;Error: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-mapErrorsNea"><a href="#val-mapErrorsNea" class="anchor"></a><code><span class="keyword">let</span> mapErrorsNea: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e1</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.Array.t(<span class="type-var">'e2</span>))</span>;</code></dt><dd><p><code>mapErrorsAsNea()</code> applies a function to each error in a <code>NonEmpty.Array</code> of errors in the error channel of the <code>Validation</code>.</p></dd></dl><dl><dt class="spec value" id="val-mapErrorsNel"><a href="#val-mapErrorsNel" class="anchor"></a><code><span class="keyword">let</span> mapErrorsNel: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e1</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, Relude_NonEmpty.List.t(<span class="type-var">'e2</span>))</span>;</code></dt><dd><p><code>mapErrorsAsNel()</code> applies a function to each error in a <code>NonEmpty.List</code> of errors in the error channel of the <code>Validation</code>.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p>In <code>tapError(f, x)</code>, function <code>f()</code> returns <code>unit</code>. Thus, <code>f()</code> is used only for its side effects. If <code>x</code> is of the form <code>VError(v)</code>, <code>tap()</code> calls <code>f(v)</code>. The <code>tap()</code> function returns the argument <code>x</code>.</p><pre><code class="ml">tapError(x =&gt; Js.log(x), VOk(4)) == VOk(4); // prints nothing
tapError(x =&gt; Js.log(x), VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints &quot;bad&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e2</span>)</span>;</code></dt><dd><p><code>bimap(f, g, x)</code> returns <code>VOk(f(v))</code> if <code>x</code> is of the form <code>VOk(v)</code>; it returns <code>VError(g(e))</code> if <code>x</code> is of the form <code>VError(e)</code>.</p><pre><code class="ml">let cube = x =&gt; x * x * x;
let label = x =&gt; &quot;Error: &quot; ++ x;
bimap(cube, label, VOk(12)) == VOk(1728);
bimap(cube, label, VError(&quot;bad&quot;)) == VError(&quot;Error: bad&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-bitap"><a href="#val-bitap" class="anchor"></a><code><span class="keyword">let</span> bitap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>bitap(f, g, x)</code> the functions <code>f()</code> and <code>g()</code> both return <code>unit</code>, so they are used only for their side effects. If <code>x</code> is of the form <code>VOk(v)</code>, <code>bitap()</code> calls <code>f(v)</code>; if <code>x</code> is of the form <code>VError(e)</code>, <code>bitap()</code> calls <code>g(e)</code>. In either case, <code>bitap()</code> returns <code>x</code>.</p><pre><code class="ml">let printCube = x =&gt; Js.log(x * x * x);
let printLabel = x =&gt; Js.log(&quot;Error: &quot; ++ x);
bitap(printCube, printLabel, VOk(12)) == VOk(12); // prints 1728
bitap(printCube, printLabel, VError(&quot;bad&quot;)) == VError(&quot;bad&quot;); // prints &quot;Error: bad&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-applyWithAppendErrors"><a href="#val-applyWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> applyWithAppendErrors: a b e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>apply(valFcn, x, appErrFcn)</code> provides a way of creating a chain of validation functions, accumulating errors along the way.</p><p>If <code>valFcn</code> is of the form <code>VOk(f)</code>, function <code>f</code> is applied to <code>x</code>. If <code>x</code> is <code>VOk(v)</code>, the result is <code>VOk(f(v))</code>. If <code>x</code> is <code>VError(err)</code>, the error is passed onwards.</p><p>If <code>valFcn</code> is itself of the form <code>VError(err)</code> and <code>x</code> is <code>VOk(v)</code>, <code>VError(err)</code> is passed on.</p><p>Finally, if both <code>valFcn</code> and <code>x</code> are <code>VError(e1)</code> and <code>VError(e2)</code>, the result is <code>VError(appendErrFcn(e1, e2))</code>.</p><p>Using <code>apply()</code> properly is somewhat complex. See the example in the <code>__tests__/Relude_Validation_test.re</code> file for more details.</p></dd></dl><dl><dt class="spec value" id="val-alignWithAppendErrors"><a href="#val-alignWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> alignWithAppendErrors: a b e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-alignWithWithAppendErrors"><a href="#val-alignWithWithAppendErrors" class="anchor"></a><code><span class="keyword">let</span> alignWithWithAppendErrors: a b c e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>pure(val)</code> wraps its argument in a <code>VOk()</code>.</p><pre><code class="ml">pure(3) == VOk(3);</code></pre></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>flatMapV(x, f)</code> returns <code>f(v)</code> when <code>x</code> is of the form <code>VOk(v)</code>, and returns <code>x</code> unchanged when it is of the form <code>VError(v)</code>.</p><p>Note: <code>Validation</code> is not a traditional monad in that it's purpose is to collect errors during applicative validation. Using <code>flatMap</code> will cause all previous errors to be discarded.</p><pre><code class="ml">let mustBeEven = x =&gt;
  (x mod 2 == 0) ? VOk(x) : VError(&quot;not even&quot;);

flatMapV(VOk(12), mustBeEven) == VOk(12);
flatMapV(VOk(3), mustBeEven) == VError(&quot;not even&quot;);
flatMapV(VError(&quot;not an int&quot;), mustBeEven) == VError(&quot;not an int&quot;);</code></pre></dd></dl><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>bind</code> is the same as <code>flatMap</code> with the arguments flipped.</p></dd></dl><dl><dt class="spec value" id="val-fromResult"><a href="#val-fromResult" class="anchor"></a><code><span class="keyword">let</span> fromResult: Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p><code>fromResult</code> converts a value of type <code>result</code> to a <code>Validation.t</code>, returning <code>VOk(x)</code> if the result was <code>Ok(x)</code> and <code>VError(x)</code> if the result was <code>Error(x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-toResult"><a href="#val-toResult" class="anchor"></a><code><span class="keyword">let</span> toResult: <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p><code>toResult</code> converts a value of type <code>Validation.t</code> to <code>result</code>.</p></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span class="type-var">'e</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>fromOption</code> converts an <code>option</code> into a <code>Validation.t</code>, returning <code>VOk(x)</code> if the option was <code>Some(x)</code> and <code>VError</code> (constructed with the provided error) if the option was <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-fromOptionLazy"><a href="#val-fromOptionLazy" class="anchor"></a><code><span class="keyword">let</span> fromOptionLazy: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>fromOptionLazy</code> converts an <code>option</code> into a <code>Validation.t</code>, similar to <code>fromOption</code>, except that provided error is constructed lazily by calling a function. This is useful if the error is expensive to construct, especially since it may not be needed.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: a e c. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>;</code></dt><dd><p><code>fold(errFn, okFn, x)</code> returns <code>okFn(v)</code> when the provided Validation (<code>x</code>) is <code>VOk(v)</code>; it returns <code>errFn(e)</code> when the Validation is <code>VError(e)</code>. This is effectively a function that allows you to &quot;handle&quot; both possible states of the Validation.</p><pre><code class="ml">let positiveInt = str =&gt;
  Validate.(
    Int.fromtString(str)
    |&gt; fromOption(`InvalidInput)
    |&gt; flatMapV(x =&gt; x &lt; 0 ? error(`NotPositive) : pure(x))
  );

let showError =
  fun
  | `InvalidInput =&gt; &quot;The provided string was not an int&quot;
  | `NotPositive =&gt; &quot;The provided int was negative&quot;;

let errMsg = x =&gt; &quot;Something went wrong: &quot; ++ showError(x);
let succMsg = x =&gt; &quot;Found valid positive int: &quot; ++ Int.toString(x);

// &quot;Something went wrong: The provided string was not an int&quot;
fold(errMsg, succMsg, positiveInt(&quot;a&quot;));

// &quot;Something went wrong: The provided int was negative&quot;
fold(errMsg, succMsg, positiveInt(&quot;-3&quot;));

// &quot;Found valid positive int: 123&quot;
fold(errMsg, succMsg, positiveInt(&quot;123&quot;));</code></pre></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p><code>flip</code> Flips the values between the success and error channels.</p><pre><code class="ml">flip(VOk(12)) == VError(12);
flip(VError(-1)) == VOk(-1);</code></pre></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">let</span> map2: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">let</span> map3: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">let</span> map4: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span>;</code></dt><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">let</span> map5: <span>(<span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span> <span>=&gt;</span> <span class="type-var">'x</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>, <span class="type-var">'x</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'f</span>, <span class="type-var">'x</span>)</span>;</code></dt></dl><div class="spec module" id="module-WithErrors"><a href="#module-WithErrors" class="anchor"></a><code><span class="keyword">module</span> <a href="WithErrors">WithErrors</a>:  (<a href="WithErrors#argument-1-Errors">Errors</a>: BsBastet.Interface.SEMIGROUP_ANY) <span>=&gt;</span>  (<a href="WithErrors#argument-2-Error">Error</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></div></div></body></html>