<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_HMap (api.Relude_HMap)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_HMap</nav><h1>Module <code>Relude_HMap</code></h1></header><dl><dt class="spec module" id="module-Witness"><a href="#module-Witness" class="anchor"></a><code><span class="keyword">module</span> <a href="Witness">Witness</a>: { ... };</code></dt><dd><p>Witness contains a type <code>t</code> with an existential type variable - a type that we capture, but lose knowledge of once captured.</p></dd></dl><dl><dt class="spec module-type" id="module-type-WITNESS"><a href="#module-type-WITNESS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITNESS">WITNESS</a> = { ... };</code></dt><dd><p><code>WITNESS</code> captures a type <code>t</code> with a <code>Witness</code> module for that type. Because <code>Witness.t(_)</code> is an extensible variant, we use <code>+=</code> to add a constructor to that type.</p></dd></dl><dl><dt class="spec type" id="type-witness"><a href="#type-witness" class="anchor"></a><code><span class="keyword">type</span> witness('a)</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-WITNESS">WITNESS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-WITNESS#type-t">t</a> = <span class="type-var">'a</span>)</span></code>;</dt><dd><p><code>witness('a)</code> is a type which captures a WITNESS module for the given type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-makeWitness"><a href="#val-makeWitness" class="anchor"></a><code><span class="keyword">let</span> makeWitness: unit <span>=&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-WITNESS">WITNESS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-WITNESS#type-t">t</a> = <span class="type-var">'a</span>)</span>;</code></dt><dd><p><code>makeWitness</code> makes a Witness module for the given type <code>a</code></p></dd></dl><dl><dt class="spec type" id="type-typeEq"><a href="#type-typeEq" class="anchor"></a><code><span class="keyword">type</span> typeEq('a, 'b)</code><code> = </code><table class="variant"><tr id="type-typeEq.TypeEq" class="anchored"><td class="def constructor"><a href="#type-typeEq.TypeEq" class="anchor"></a><code>| </code><code><span class="constructor">TypeEq</span> : <a href="#type-typeEq">typeEq</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span></code></td></tr></table>;</dt><dd><p><code>typeEq('a, 'b)</code> contains a single constructor TypeEq which can only be constructed if <code>'a</code> and <code>'b</code> are the same types.</p><p>This is used for a type-level type equality check.</p></dd></dl><dl><dt class="spec value" id="val-typeEq"><a href="#val-typeEq" class="anchor"></a><code><span class="keyword">let</span> typeEq: l r. <a href="#type-witness">witness</a>(<span class="type-var">'l</span>) <span>=&gt;</span> <a href="#type-witness">witness</a>(<span class="type-var">'r</span>) <span>=&gt;</span> option(<a href="#type-typeEq">typeEq</a><span>(<span class="type-var">'l</span>, <span class="type-var">'r</span>)</span>);</code></dt><dd><p><code>typeEq</code> checks whether the give witness types are equal.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KEY_META"><a href="#module-type-KEY_META" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KEY_META">KEY_META</a> = { ... };</code></dt><dd><p><code>KEY_META</code> is a module type signature which captures the type of a map key.</p></dd></dl><dl><dt class="spec module-type" id="module-type-HMAP_TYPE"><a href="#module-type-HMAP_TYPE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HMAP_TYPE">HMAP_TYPE</a> = { ... };</code></dt><dd><p><code>HMAP_TYPE</code> is a module type signature which captures the types and functions exposed by the HMap.</p></dd></dl><dl><dt class="spec module" id="module-WithKeyMeta"><a href="#module-WithKeyMeta" class="anchor"></a><code><span class="keyword">module</span> <a href="WithKeyMeta">WithKeyMeta</a>:  (<a href="WithKeyMeta/argument-1-KeyMeta">KeyMeta</a>: <a href="#module-type-KEY_META">KEY_META</a>) <span>=&gt;</span> <a href="#module-type-HMAP_TYPE">HMAP_TYPE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithKeyMeta/Key#type-keyMeta">Key.keyMeta</a>('a) = <a href="WithKeyMeta/argument-1-KeyMeta#type-t">KeyMeta.t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>Make creates a Map module for the given KEY_META.</p></dd></dl><dl><dt class="spec module" id="module-WithKeyMetaUnit"><a href="#module-WithKeyMetaUnit" class="anchor"></a><code><span class="keyword">module</span> <a href="WithKeyMetaUnit">WithKeyMetaUnit</a>: { ... };</code></dt><dd><p>We include a default HMap implementation which uses <code>unit</code> as it's key meta type. Note that this default map type will not work in a type-safe way for functions that iterate over the map with keyValue functions, like fold, all, any, etc.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="#module-WithKeyMetaUnit">WithKeyMetaUnit</a><span class="keyword">;</span></code></span></summary><dl><dt class="spec type" id="type-keyImpl"><a href="#type-keyImpl" class="anchor"></a><code><span class="keyword">type</span> keyImpl('a)</code>;</dt><dd><p>An abstract type for map keys</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> Key = <a href="WithKeyMetaUnit#module-Key">WithKeyMetaUnit.Key</a>;</code></dt><dd><p>Key-related types and operations for an HMap</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code>;</dt><dd><p>The abstract type of the HMap</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: <a href="#type-t">t</a>;</code></dt><dd><p>An empty HMap</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if the HMap is empty</p></dd></dl><dl><dt class="spec value" id="val-hasKey"><a href="#val-hasKey" class="anchor"></a><code><span class="keyword">let</span> hasKey: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if the HMap has a value for the given key</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">let</span> add: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>Adds the given key/value pair to the HMap</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">let</span> singleton: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>Creates an HMap with the given key/value pair</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>Creates a new HMap that does not contain a value for the given key</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>Looks up a value in the HMap for the given key</p></dd></dl><dl><dt class="spec type" id="type-keyValue"><a href="#type-keyValue" class="anchor"></a><code><span class="keyword">type</span> keyValue</code><code> = </code><table class="variant"><tr id="type-keyValue.KeyValue" class="anchored"><td class="def constructor"><a href="#type-keyValue.KeyValue" class="anchor"></a><code>| </code><code><span class="constructor">KeyValue</span>(<a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>), <span class="type-var">'a</span>) : <a href="#type-keyValue">keyValue</a></code></td></tr></table>;</dt><dd><p>The type of a key/value pair in the HMap. The key captures the type of the corresponding value.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> unit;</code></dt><dd><p>Runs a side effect for each key/value pair in the HMap. Note: the KEY_META must provide appropriate functions for converting the existentially typed values into values of a known type.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>Folds the HMap into a value. Note the KEY_META must provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if all key/value pairs in the HMap satisfy the given predicate.</p><p>Note the KEY_META must provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Indicates if any key/value pairs in the HMap satisfy the given predicate.</p><p>Note the KEY_META must provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>Creates a new HMap that only contains the key/value pairs that satisfy the given predicate.</p><p>Note the KEY_META must provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">let</span> size: <a href="#type-t">t</a> <span>=&gt;</span> int;</code></dt><dd><p>Gets the number of key/value pairs stored in this HMap.</p></dd></dl></details></div></div></div></div></body></html>