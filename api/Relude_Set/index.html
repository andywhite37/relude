<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Set (api.Relude_Set)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Set</nav><h1>Module <code>Relude_Set</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('value, 'id)</code><code> = Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span></code>;</dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p><code>Set.empty</code> constructs a new, empty set given an identity module.</p></dd></dl><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p><code>Set.fromArray</code> converts an array of values into a new set of those values, ordered by the comparator function from the provided <code>Comparable</code> module.</p></dd></dl><dl><dt class="spec value" id="val-fromList"><a href="#val-fromList" class="anchor"></a><code><span class="keyword">let</span> fromList: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p><code>Set.fromList</code> converts a list of values into a new set of those values, ordered by the comparator function <code>Comparable.cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a set is empty.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a set contains a given value.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">let</span> add: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably add a value to a set. If the value already exists in the set, the original set (physical reference) is returned unchanged. Otherwise, a new copy of the set is returned containing the value.</p></dd></dl><dl><dt class="spec value" id="val-mergeMany"><a href="#val-mergeMany" class="anchor"></a><code><span class="keyword">let</span> mergeMany: array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably merge an array of values into a set.</p><p>Note: unlike <a href="#val-add"><code>add</code></a> if the set already contains all the values in the array, the return value may or may not be a new reference. Otherwise, a new set reference is returned.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably remove a value from a set. If the value is not found in the set, the original set (physical reference) is returned unchanged. Otherwise, a new set is returned containing the value.</p></dd></dl><dl><dt class="spec value" id="val-removeMany"><a href="#val-removeMany" class="anchor"></a><code><span class="keyword">let</span> removeMany: array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably remove multiple values from a set. Note: unlike <code>remove</code>, if none of the values in the array are found in the set, the return value may or may not be a new reference. Otherwise, a new set reference is returned.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">let</span> update: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably update a set with a new value. If an equivalent value already exists in the set, it will be immutably removed before adding the new value. In ether case, a new physical reference to the set will be returned.</p><p>Note: unlike <a href="#val-add"><code>add</code></a>, <code>update</code> guarantees that the value's physical reference will be added to the set.</p></dd></dl><dl><dt class="spec value" id="val-toggle"><a href="#val-toggle" class="anchor"></a><code><span class="keyword">let</span> toggle: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Immutably add a value to a set if it does not already exist. If an equivalent value already exists in the set, it will be removed. In either case, a new physical reference to the set will be returned.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">let</span> union: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Returns a new set representing the union of two sets.</p><pre><code class="ml">let s1 = fromList([1, 3, 4, 5, 2, 1]);
let s2 = fromList([1, 0, 3, 2, 9]);
Set.union(s1, s2) |&gt; toList == [0, 1, 2, 3, 4, 5, 9];</code></pre></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">let</span> intersect: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Returns a new set representing the intersection of two sets.</p><pre><code class="ml">let s1 = fromList([0, 1, 2, 3, 4, 1]);
let s2 = fromList([0, 3, 9, 8, 10]);
Set.intersect(s1, s2) |&gt; toList == [0, 3];</code></pre></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">let</span> diff: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Returns a new set which contains all the elements of the first set that are not present in the second set.</p><p>Note: The argument order is significant for this function.</p><pre><code class="ml">let s1 = fromList([0, 1, 2, 3, 4, 1]);
let s2 = fromList([0, 3, 9, 8, 10]);

diff(s1, s2) |&gt; toList == [1, 2, 4];
diff(s2, s1) |&gt; toList == [8, 9, 10];</code></pre></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">let</span> subset: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p><code>subset(s1, s2)</code> will return <code>true</code> if <code>s2</code> is a subset of <code>s1</code>.</p><p>Note: The argument order is significant for this function.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">let</span> compare: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>Returns an integer value of <code>-1 | 0 | 1</code>, representing the total ordering between two sets. This can be used as a comparator function to determine the ordering of nested sets (e.g. <code>Set.t(Set.t('a))</code>);</p><p>Note: The argument order is significant for this function.</p><pre><code class="ml">let s0 = Test1.fromList([1, 2, 3, 4]);
let s1 = Test1.fromList([1, 2, 3, 4]);
let s2 = Test1.fromList([2, 3, 4, 5, 6]);
let s3 = Test1.fromList([100, 0]);

Set.compare(s0, s1) == 0;
Set.compare(s0, s2) == -1;
Set.compare(s0, s3) == 1;

Set.compare(s1, s2) == -1;
Set.compare(s1, s3) == 1;
Set.compare(s2, s3) == 1;</code></pre></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">let</span> eq: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether two sets are equivalent.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<span class="type-var">'value</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Apply a function to each element of a set, in increasing order.</p></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Iterate over the values of a set in increasing order, accumulating a final value of an arbitraty type.</p></dd></dl><dl><dt class="spec value" id="val-foldRight"><a href="#val-foldRight" class="anchor"></a><code><span class="keyword">let</span> foldRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>TODO: optimize foldRight for sets. This remains unimplemented in <code>Belt</code>'s API, but it exists in PureScript/Haskell, since <code>Set</code> implements <code>Foldable</code>.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a given predicate holds true for all values in a given set.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>Determine whether a given predicate holds true for at least one value in a given set.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Create a new set from another set containing only the values which pass a given test (the predicate function).</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">let</span> keep: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p><code>Set.keep</code> is an alias for <a href="#val-filter"><code>filter</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-filterNot"><a href="#val-filterNot" class="anchor"></a><code><span class="keyword">let</span> filterNot: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>Creates a new set from another set containing only the values which do <em>not</em> pass a given test (the predicate function)</p></dd></dl><dl><dt class="spec value" id="val-reject"><a href="#val-reject" class="anchor"></a><code><span class="keyword">let</span> reject: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p><code>Set.reject</code> is an alias for <span class="xref-unresolved" title="unresolved reference to &quot;val.filterNot&quot;"><code>val</code>.filterNot</span>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">let</span> partition: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>;</code></dt><dd><p>Immutably divide a set into a tuple of two sets, where the first set contains all the values which pass the predicate function test, and the second one contains all the values which fail.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>Returns the total number of elements in a set.</p></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>);</code></dt><dd><p>Creates a new array containing all elements of the set in ascending order based on the associated comparator function.</p></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>);</code></dt><dd><p>Creates a new list containing all elements of the set in ascending order based on the associated comparator function.</p></dd></dl><dl><dt class="spec value" id="val-minimum"><a href="#val-minimum" class="anchor"></a><code><span class="keyword">let</span> minimum: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>Optionally returns the lowest ordered element in a given set or <code>None</code> if the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-maximum"><a href="#val-maximum" class="anchor"></a><code><span class="keyword">let</span> maximum: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>Optionally returns the highest ordered element in a given set or <code>None</code> if the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>Optionally returns an equivalent element from a set or <code>None</code> if no equivalent element is found, or the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'value</span>;</code></dt><dd><p>Returns an equivalent element from a set if one exists, or else returns a specified default value.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">let</span> split: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span>(<a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>, bool)</span>;</code></dt><dd><p>TODO: Needs documentation. Belt doesn't provide much description.</p></dd></dl><div class="spec module-type" id="module-type-SET"><a href="#module-type-SET" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SET">SET</a> = { ... };</code></div><div class="spec module" id="module-WithOrd"><a href="#module-WithOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="WithOrd">WithOrd</a>:  (<a href="WithOrd#argument-1-M">M</a>: BsBastet.Interface.ORD) <span>=&gt;</span> <a href="#module-type-SET">SET</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithOrd#type-value">value</a> = <a href="WithOrd#argument-1-M">M</a>.t;</code></div></div></body></html>