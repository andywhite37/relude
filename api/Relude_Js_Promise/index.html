<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Js_Promise (api.Relude_Js_Promise)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Js_Promise</nav><h1>Module <code>Relude_Js_Promise</code></h1></header><dl><dt class="spec value" id="val-toIO"><a href="#val-toIO" class="anchor"></a><code><span class="keyword">let</span> toIO: a. Js.Promise.t(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Promise.error)</span>;</code></dt><dd><p><code>Relude.Js.Promise</code> contains utilities for interoperating with <code>Js.Promise</code>. Many of these functions will help you convert to and from <code>Relude.IO</code>.</p><p>Lifts a <code>Js.Promise</code> into a <code>Relude.IO</code></p><p>Note: prefer <a href="#val-toIOLazy"><code>toIOLazy</code></a> over this function if possible. A <code>Js.Promise</code> is eagerly executed, so using <code>toIO</code> with an already-constructed and running <code>Js.Promise</code> will not suspend the side effects.</p></dd></dl><dl><dt class="spec value" id="val-toIOLazy"><a href="#val-toIOLazy" class="anchor"></a><code><span class="keyword">let</span> toIOLazy: a. <span>(unit <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>))</span> <span>=&gt;</span> Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Promise.error)</span>;</code></dt><dd><p>Lifts a lazily-executed <code>Js.Promise</code> into a <code>Relude.IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-fromIOWithResult"><a href="#val-fromIOWithResult" class="anchor"></a><code><span class="keyword">let</span> fromIOWithResult: a e. Relude_IO.t<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Js.Promise.t(Pervasives.result<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span>);</code></dt><dd><p>Converts a <code>Relude.IO</code> into a <code>Js.Promise.t</code>. This function will cause the IO effects to be run.</p><p>The promise that is returned will not reject, it will instead have a <code>result</code> as its resolution.</p></dd></dl><dl><dt class="spec value" id="val-fromIO"><a href="#val-fromIO" class="anchor"></a><code><span class="keyword">let</span> fromIO: a e. Relude_IO.t<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a <code>Relude.IO</code> into a <code>Js.Promise.t</code>. This function will cause the IO effects to be run.</p><p>The error channel is unsafely coerced into the promise error type, which is probably fine, because the <code>Js.Promise</code> error type is opaque.</p></dd></dl><dl><dt class="spec value" id="val-fromIOExn"><a href="#val-fromIOExn" class="anchor"></a><code><span class="keyword">let</span> fromIOExn: a. Relude_IO.t<span>(<span class="type-var">'a</span>, exn)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a <code>Relude.IO</code> with an extensible OCaml <code>exn</code> as the error type into a <code>Js.Promise.t</code>. This function will cause the IO effects to be run.</p></dd></dl><dl><dt class="spec value" id="val-fromIOJsExn"><a href="#val-fromIOJsExn" class="anchor"></a><code><span class="keyword">let</span> fromIOJsExn: a. Relude_IO.t<span>(<span class="type-var">'a</span>, Js.Exn.t)</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>);</code></dt><dd><p>Converts a <code>Relude.IO</code> with a <code>Js.Exn.t</code> as the error type into a <code>Js.Promise.t</code>. This function will cause the IO effects to be run.</p></dd></dl></div></body></html>