<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_IO (api.Relude_IO)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> â€“ <a href="../">api</a> &#x00BB; Relude_IO</nav><h1>Module <code>Relude_IO</code></h1><p><code>Relude.IO</code> contains a type <code>t('a, 'e)</code> and related functions for representing and controlling the execution of side effects.</p><h3 id="what-is-io?"><a href="#what-is-io?" class="anchor"></a>What is IO?</h3><p>Side effects are a normal part of building a useful program. Side effects cover everything from reading user input to making HTTP requests to drawing output on the screen. Really, a side effect is any change (in application state or in the universe) that can be observed outside of a function other than that function's returned value.</p><p>While side effects are important for building a program that actually <em>does</em> something, they are inherently impure. This is obviously at odds with writing <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a> code. IO seeks to restore this purity by <em>describing</em> these effects (and transformations on top of these effects) as data. Doing so allows us to be much more precise about when our effects actually run, and we can more easily reuse, reason about, and confidently refactor these descriptions of effects.</p><p><code>IO</code> can represent any type of synchronous or asynchronous side effect that can either produce a value (in the success channel <code>'a</code>) or an error (in the error channel <code>'e</code>). The main purpose of <code>IO</code> is to make side-effectful code <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>. When you construct an <code>IO</code>, in most cases you are just suspending the execution of a side effect, rather than allowing it to execute immediately.</p><p>In the case of a synchronous effect like a <code>Js.log(...)</code>, which writes to the console, or <code>getCurrentDate()</code>, which reads the current clock time from the system, or <code>Math.random()</code>, which generates a random number out of the blue, it simply makes the action lazy, using a thunk like <code>unit =&gt; effect</code>.</p><p>In the case of asynchronous side effects, the execution of the effect is suspended until the <code>IO</code> is run using <code>unsafeRunAsync</code>. Because <code>IO</code> can represent both synchronous and asynchronous side effects, the end result of executing an <code>IO</code> must always be handled via a callback, as if the effect were async.</p><h3 id="why-is-running-an-io-considered-unsafe?"><a href="#why-is-running-an-io-considered-unsafe?" class="anchor"></a>Why is running an <code>IO</code> considered unsafe?</h3><p>An <code>IO</code> value represents a &quot;description&quot; or &quot;recipe&quot; of one or more side effects to perform. When you run an <code>IO</code>, all of the suspended effects are executed, and all of the side effects will occur. Naming the run function <code>unsafeRunAsync</code> is intended to warn you that invoking the function will execute your side effects.</p><p>Describing these functions as &quot;unsafe&quot; is a convention in the FP community for performing <code>IO</code> effects:</p><ul><li><a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO-Unsafe.html">Haskell IO</a>,</li><li><a href="https://pursuit.purescript.org/packages/purescript-effect/2.0.1/docs/Effect.Unsafe#v:unsafePerformEffect">Purescript Effect</a>,</li><li><a href="https://typelevel.org/cats-effect/datatypes/io.html#unsafe-operations">Cats Effect IO</a>.</li></ul><h3 id="relation-to-js.promise"><a href="#relation-to-js.promise" class="anchor"></a>Relation to <code>Js.Promise</code></h3><p>If you are coming from the JavaScript world, don't be afraid of <code>IO</code> - in many ways, you can basically just think of it as a construct similar to <code>Promise</code>, with the following key differences:</p><h4 id="eager-vs-lazy"><a href="#eager-vs-lazy" class="anchor"></a>Eager vs lazy</h4><p><code>Promise</code> is eagerly-executed and <code>IO</code> is lazily-executed. When you construct a <code>Promise</code>, its execution is immediately started, and it will invoke its success or failure callbacks whenever it finishes. <code>IO</code> is lazily-executed, so it will not do anything until you &quot;run&quot; the <code>IO</code> using <code>unsafeRunAsync</code>, which provides you with the resulting value or error using a callback from <code>result('a, 'e) =&gt; unit</code>.</p><p>As a result, functions that return a <code>Promise</code> are inherently impure (they've already started performing an effect), while functions that return <code>IO</code> are not (they've returned a data structure describing how an effect will be performed in the future).</p><h4 id="memoization"><a href="#memoization" class="anchor"></a>Memoization</h4><p><code>Promise</code> <a href="https://en.wikipedia.org/wiki/Memoization">memoizes</a> its result value, and <code>IO</code> does not. This means that once a <code>Promise</code> is resolved or rejected, it will hold onto the resulting value or error, and any future uses of <code>then</code> or <code>catch</code> will produce that same value or error, rather than re-running the <code>Promise</code> and producing a new value or error.</p><p><code>IO</code> doesn't have built-in memoization of the value, so re-running an <code>IO</code> will cause all the effects to be re-run, and a new value (or error) will be produced.</p><h4 id="error-handling"><a href="#error-handling" class="anchor"></a>Error handling</h4><p>A <code>Promise</code> can fail (be rejected) with any type of value, and in JavaScript, the only way to tell what type of error occurred is to inspect the error value and/or its type at runtime. For this reason, the BuckleScript bindings choose to represent a <code>Promise</code> error as an <a href="https://bucklescript.github.io/bucklescript/api/Js.Promise.html#TYPEerror">opaque type</a>. Opaque types require runtime inspection or unsafe casting before they can be used.</p><p><code>IO.t('a, 'e)</code> uses the <code>'e</code> type parameter to let you express to the type system whatever type of error makes most sense for your needs. In some cases, you may not care about the details of the error and can choose to use an opaque type or <code>unit</code>. In other cases, you may wish to pass along custom errors that carry lots of extra information. Either way, the choice is yours, and that flexibility makes errors much easier to work with,</p><h3 id="more-about-&quot;effects&quot;"><a href="#more-about-&quot;effects&quot;" class="anchor"></a>More about &quot;effects&quot;</h3><p>The word &quot;effect&quot; is a bit overloaded in the functional programming world. We often hear about &quot;side effects,&quot; and this term is typically referring to things like writing to stdout, making a network call, getting the system time, generating a random number - these are all things that either send information to the outside world, or pull information in from the outside world. They are called &quot;side effects&quot; because the function has an effect on the system beyond its input arguments and output return value - it does something that is not represented by the input and output types.</p><p>Another place in functional programming where the term &quot;effect&quot; appears is when we talk about data types like <code>option('a)</code> or <code>result('a, 'e)</code>. These types of values are often called &quot;effectful&quot; values, because they represent some sort of additional &quot;effect&quot; that may have occurred. For example if you have a function <code>a =&gt; b</code>, assuming it's a pure function, the only possible value you can get out of the function is a value of type <code>'b</code> - there's no way to represent a failure, an asynchronous computation, or a case where the function can't produce a value. If instead the function is <code>'a =&gt; option('b)</code>, the function can now either produce a value of type <code>'a</code>, or fail to produce a value (<code>None</code>).</p><p>This behavior is often called the &quot;effect&quot; of producing a value with the possibility of not being able to produce a value. For <code>'a =&gt; result('b, 'e)</code>, we have the &quot;effect&quot; of either producing a value or an error. <code>Js.Promise</code> is another effectful value in that it has the &quot;effect&quot; of asynchronous computation (a value will be produced at some time later), and the &quot;effect&quot; of possible failure. In terms of <code>IO</code>, this is important because not only can <code>IO</code> suspend actual &quot;side effects&quot; (like stdout/network/etc.), but it can also represent the types of &quot;effects&quot; like <code>option('a)</code>, <code>result('a, 'e)</code>, <code>Js.Promise.t</code>, etc.</p><p>All of these types of &quot;effectful&quot; values can be converted to an <code>IO</code>, so that you can easily compose all of these different effects in a single expression. When you try to write code in the monadic style (e.g. using chained <code>flatMap</code> or <code>&gt;&gt;=</code> operations), it can be quite convenient to be able to deal with various types of side effects and &quot;functional effects&quot; using a single Monad.</p><h3 id="further-reading"><a href="#further-reading" class="anchor"></a>Further reading</h3><p>This type is inspired by and based on the recent work that has gone into the concept of bi-functor IO in the FP community:</p><ul><li><p>John De Goes' blog posts</p><ul><li><a href="http://degoes.net/articles/bifunctor-io">Bifunctor IO: A Step Away from Dynamically-Typed Error Handling</a></li><li><a href="http://degoes.net/articles/zio-environment">Beautiful, Simple, Testable Functional Effects for Scala</a></li></ul></li><li><a href="https://github.com/zio/zio">ZIO</a></li><li><a href="https://github.com/LukaJCB/cats-bio">cats-bio</a></li><li><a href="https://github.com/slamdata/purescript-aff/issues/137">PureScript Aff Discussion</a></li></ul></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a, 'e)</code><code> = </code><table class="variant"><tr id="type-t.Pure" class="anchored"><td class="def constructor"><a href="#type-t.Pure" class="anchor"></a><code>| </code><code><span class="constructor">Pure</span>(<span class="type-var">'a</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Throw" class="anchored"><td class="def constructor"><a href="#type-t.Throw" class="anchor"></a><code>| </code><code><span class="constructor">Throw</span>(<span class="type-var">'e</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Suspend" class="anchored"><td class="def constructor"><a href="#type-t.Suspend" class="anchor"></a><code>| </code><code><span class="constructor">Suspend</span>(<span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.SuspendIO" class="anchored"><td class="def constructor"><a href="#type-t.SuspendIO" class="anchor"></a><code>| </code><code><span class="constructor">SuspendIO</span>(<span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Async" class="anchored"><td class="def constructor"><a href="#type-t.Async" class="anchor"></a><code>| </code><code><span class="constructor">Async</span>(<span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Map" class="anchored"><td class="def constructor"><a href="#type-t.Map" class="anchor"></a><code>| </code><code><span class="constructor">Map</span>(<span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>,Â <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.Apply" class="anchored"><td class="def constructor"><a href="#type-t.Apply" class="anchor"></a><code>| </code><code><span class="constructor">Apply</span>(<a href="#type-t">t</a><span>(<span class="type-var">'r</span> <span>=&gt;</span> <span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>,Â <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr><tr id="type-t.FlatMap" class="anchored"><td class="def constructor"><a href="#type-t.FlatMap" class="anchor"></a><code>| </code><code><span class="constructor">FlatMap</span>(<span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'r</span>,Â <span class="type-var">'e</span>)</span>) : <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></code></td></tr></table>;</dt><dd><p>IO is a bi-functor effect type that supports both synchronous and asynchronous effects, with explicit error handling.</p><p>This is inspired by the following libraries/articles:</p><ul><li>John De Goes - http://degoes.net/articles/only-one-io and http://degoes.net/articles/bifunctor-io</li><li>ZIO/Scalaz 8 IO (Scala) - https://github.com/zio/zio</li><li>cats-bio (Scala) - https://github.com/LukaJCB/cats-bio</li><li>purescript-aff discussion (Purescript) - https://github.com/slamdata/purescript-aff/issues/137</li></ul></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a e. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.pure</code> constructs an <code>IO</code> from the provided value. However, the fact that you are able to provide a value suggests that the effect has already run.</p><p>In many cases, it's preferable to use <code>suspend</code>, especailly for values that are expensive to construct or may produce observable effects.</p></dd></dl><dl><dt class="spec value" id="val-pureWithVoid"><a href="#val-pureWithVoid" class="anchor"></a><code><span class="keyword">let</span> pureWithVoid: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â Relude_Void.t)</span>;</code></dt><dd><p><code>IO.pureWithVoid</code> Wraps a non-failing, strictly-evaluated value in an <code>IO</code>. Unlike the normal <code>pure</code> function, this version uses <code>Void.t</code> in the error channel to indicate that no unhandled error exists.</p><p>As with <code>pure</code>, you should prefer <code>suspend</code> for values that are expensive to construct or may have side-effects.</p></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">let</span> unit: e. <a href="#type-t">t</a><span>(unit,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.unit</code> represents an <code>IO</code> that successfully resolves to <code>()</code>.</p></dd></dl><dl><dt class="spec value" id="val-unitWithVoid"><a href="#val-unitWithVoid" class="anchor"></a><code><span class="keyword">let</span> unitWithVoid: <a href="#type-t">t</a><span>(unit,Â Relude_Void.t)</span>;</code></dt><dd><p><code>IO.unitWithVoid</code> represents an <code>IO</code> that successfully resolves to <code>()</code>. Unlike <code>IO.unit</code>, this function indicates that it has no unhandled errors by using <code>Void.t</code> in the error channel.</p></dd></dl><dl><dt class="spec value" id="val-throw"><a href="#val-throw" class="anchor"></a><code><span class="keyword">let</span> throw: a e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.throw</code> wraps a strictly-evaluated error value in an <code>IO</code>.</p><p>Prefer <code>suspendThrow</code> (or variants) for values that are expensive to construct or may have side-effects.</p></dd></dl><dl><dt class="spec value" id="val-throwWithVoid"><a href="#val-throwWithVoid" class="anchor"></a><code><span class="keyword">let</span> throwWithVoid: e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Void.t,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.throwWithVoid</code> wraps a strictly-evaluated error value in an <code>IO</code>, indicating that no success can exist with a <code>Void.t</code> type in the success channel.</p></dd></dl><dl><dt class="spec value" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span class="keyword">let</span> suspend: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.suspend</code> wraps a lazily-evaluated value in an <code>IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-suspendWithVoid"><a href="#val-suspendWithVoid" class="anchor"></a><code><span class="keyword">let</span> suspendWithVoid: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â Relude_Void.t)</span>;</code></dt><dd><p><code>IO.suspendWithVoid</code> wraps a lazily-evaluated value in an <code>IO</code>. This function cannot fail, as indicated by the <code>Void.t</code> type in the error channel.</p></dd></dl><dl><dt class="spec value" id="val-suspendThrow"><a href="#val-suspendThrow" class="anchor"></a><code><span class="keyword">let</span> suspendThrow: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.suspendThrow</code> wraps a lazily-evaluated error in an <code>IO</code></p></dd></dl><dl><dt class="spec value" id="val-suspendIO"><a href="#val-suspendIO" class="anchor"></a><code><span class="keyword">let</span> suspendIO: a e. <span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.suspendIO</code> wraps a lazily-evaluated <code>IO</code> value in an <code>IO</code>.</p><p>This can be useful if you are dealing with an effectful value that is normally eagerly or strictly evaluated, like a <code>result</code> or <code>option</code> or <code>Js.Promise</code>. In this case, you would typically convert the effectful value into an <code>IO</code> using a function like <code>pure</code> or <code>throw</code>, but doing this strict conversion inside a <code>suspendIO</code> function makes the conversion lazy.</p></dd></dl><dl><dt class="spec value" id="val-async"><a href="#val-async" class="anchor"></a><code><span class="keyword">let</span> async: a e. <span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.async</code> creates an async <code>IO</code> value that is run by invoking a callback <code>result('a, 'e) =&gt; unit</code>.</p><p>This is useful for lifting other types of async effects into <code>IO</code>, like <code>Js.Promise</code> or a Node.js-style callback API.</p></dd></dl><dl><dt class="spec value" id="val-fromOption"><a href="#val-fromOption" class="anchor"></a><code><span class="keyword">let</span> fromOption: a e. <span>(unit <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> option(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.fromOption</code> onverts an <code>option('a)</code> to an <code>IO.t('a, 'e)</code> by providing a callback to use when the <code>option</code> is <code>None</code>.</p><p>Because the option is already evaluated, no effort is made to suspend any effects.</p></dd></dl><dl><dt class="spec value" id="val-fromResult"><a href="#val-fromResult" class="anchor"></a><code><span class="keyword">let</span> fromResult: a e. Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.fromResult</code> converts a <code>result('a, 'e)</code> to an <code>IO.t('a, 'e)</code>.</p><p>Because the result is already evaluated, no effort is made to suspend any effects.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.map</code> applies a function <code>'a =&gt; 'b</code> on an <code>IO.t('a, 'e)</code> to produce an <code>IO.t('b, 'e)</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;$&gt;): <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span>;</code></dt><dt class="spec value" id="val-(&lt;#&gt;)"><a href="#val-(&lt;#&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;#&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>,Â <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applies a side-effect function <code>'a =&gt; unit</code> on an <code>IO.t('a, 'e)</code>, and propagates the <code>'a</code> value unchanged.</p><p>This is useful for doing things like logging the value inside the <code>IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Applicative <code>apply</code> function</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;*&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span>;</code></dt><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.flatMap</code> pplies an effectful function <code>'a =&gt; IO.t('b, 'e)</code> on the <code>'a</code> value inside the <code>IO</code> to produce an <code>IO.t('b, 'e)</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">let</span> bind: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.bind</code> is <code>flatMap</code> with the argument order reversed. It's also an alias for the <code>&gt;&gt;=</code> &quot;bind&quot; operator.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">let</span> (&gt;&gt;=): <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>,Â <span class="type-var">'b</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>,Â <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-cond"><a href="#val-cond" class="anchor"></a><code><span class="keyword">let</span> cond: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.cond</code> applies the provided predicate function to the success value in the <code>IO</code>. If the condition is satisfied, the provided <code>'a</code> value is lifted into the <code>IO</code> and returned. If the condition fails, the provided <code>'e</code> value is lifted into the <code>IO</code> and returned. If the <code>IO</code> was already an error, the predicate function isn't run and the existing error is preserved.</p></dd></dl><dl><dt class="spec value" id="val-condError"><a href="#val-condError" class="anchor"></a><code><span class="keyword">let</span> condError: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p><code>IO.condError</code> tests the success value against a provided predicate, as <code>cond</code> does. Unlike <code>cond</code>, if the predicate passes, the existing <code>'a</code> is returned. If the condition does not pass, the new error is used instead.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsync"><a href="#val-unsafeRunAsync" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsync: a e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p><code>IO.unsafeRunAsync</code> runs the <code>IO.t('a, 'e)</code> to produce a final <code>result('a, 'e)</code>, which is provided to the caller via a callback of type <code>result('a, 'e) =&gt; unit</code>.</p><p>This function should be run &quot;at the edge of the program&quot; to evaluate the suspended side-effects in the <code>IO</code> and produce either an error of type <code>'e</code> or a successful value of type <code>'a</code>. Ideally, in simple apps, this execution happens at the end of your main function, but when using <code>IO</code> inside existing frameworks that don't natively support <code>IO</code>, the most appropriate place may be inside the context of a reducer side effect or a web app controller function.</p><p>The function uses the term &quot;unsafe&quot; because calling this function causes all of the suspended side effects to actually be executed. It is not &quot;unsafe&quot; in that it can throw an exception - it is just a convention in FP libraries to denote these types of functions as unsafe.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsyncPar2"><a href="#val-unsafeRunAsyncPar2" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsyncPar2: a b e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Runs two IOs in parallel, and invokes the given done callback when all complete</p><p>Note that applicative uses of IO (apply/map2/map3/traverse/etc.) will run the IOs in parallel, so it's rarely necessary for the end-user to call this directly.</p></dd></dl><dl><dt class="spec value" id="val-unsafeRunAsyncPar3"><a href="#val-unsafeRunAsyncPar3" class="anchor"></a><code><span class="keyword">let</span> unsafeRunAsyncPar3: a b c e. <span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>Runs three IOs in parallel, and invokes the given done callback when all complete.</p><p>Note that applicative uses of IO (apply/map2/map3/traverse/etc.) will run the IOs in parallel, so it's rarely necessary for the end-user to call this directly.</p></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">let</span> compose: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates a new IO value that contains the composition of functions from two input IO values. Composition is done from right-to-left with this function - see andThen for left-to-right.</p></dd></dl><dl><dt class="spec value" id="val-composePure"><a href="#val-composePure" class="anchor"></a><code><span class="keyword">let</span> composePure: a b c e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Pure('a =&gt; 'b)</p></dd></dl><dl><dt class="spec value" id="val-composeThrow"><a href="#val-composeThrow" class="anchor"></a><code><span class="keyword">let</span> composeThrow: a b c e. <span class="type-var">'e</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Throw</p></dd></dl><dl><dt class="spec value" id="val-composeSuspend"><a href="#val-composeSuspend" class="anchor"></a><code><span class="keyword">let</span> composeSuspend: a b c e. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Suspend</p></dd></dl><dl><dt class="spec value" id="val-composeSuspendIO"><a href="#val-composeSuspendIO" class="anchor"></a><code><span class="keyword">let</span> composeSuspendIO: a b c e. <span>(unit <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side SuspendIO</p></dd></dl><dl><dt class="spec value" id="val-composeAsync"><a href="#val-composeAsync" class="anchor"></a><code><span class="keyword">let</span> composeAsync: a b c e. <span>(<span>(Pervasives.result<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Async</p></dd></dl><dl><dt class="spec value" id="val-composeMap"><a href="#val-composeMap" class="anchor"></a><code><span class="keyword">let</span> composeMap: a b c r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Map</p></dd></dl><dl><dt class="spec value" id="val-composeApply"><a href="#val-composeApply" class="anchor"></a><code><span class="keyword">let</span> composeApply: a b c r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side Apply</p></dd></dl><dl><dt class="spec value" id="val-composeFlatMap"><a href="#val-composeFlatMap" class="anchor"></a><code><span class="keyword">let</span> composeFlatMap: a b c r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>compose specialization for a left-hand-side FlatMap</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&lt;&lt;)"><a href="#val-(&lt;&lt;&lt;)" class="anchor"></a><code><span class="keyword">let</span> (&lt;&lt;&lt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'a</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span>;</code></dt><dd><p>Operator for IO's compose right-to-left composition function</p><p>This uses triple &lt;&lt;&lt; to disambiguate from function compose &lt;&lt;</p></dd></dl><dl><dt class="spec value" id="val-andThen"><a href="#val-andThen" class="anchor"></a><code><span class="keyword">let</span> andThen: a b c e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Flipped version of compose for left-to-right usage</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;&gt;)"><a href="#val-(&gt;&gt;&gt;)" class="anchor"></a><code><span class="keyword">let</span> (&gt;&gt;&gt;): <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'d</span>,Â <span class="type-var">'c</span>)</span>;</code></dt><dd><p>Operator for IO's andThen left-to-right composition function</p><p>This uses triple &gt;&gt;&gt; to disambiguate from function andThen &gt;&gt;</p></dd></dl><dl><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Same as <code>map</code>, but operates on the error channel.</p></dd></dl><dl><dt class="spec value" id="val-tapError"><a href="#val-tapError" class="anchor"></a><code><span class="keyword">let</span> tapError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Same as <code>tap</code>, but operates on the error channel.</p></dd></dl><dl><dt class="spec value" id="val-catchError"><a href="#val-catchError" class="anchor"></a><code><span class="keyword">let</span> catchError: a e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Handles an error of types <code>'e1</code> from an <code>IO.t('a, 'e1)</code> and converts it into a new <code>IO.t('a, 'e1)</code> value. This is much like <code>flatMap</code>/<code>bind</code> but works for the error channel of the <code>IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-catchErrorMap"><a href="#val-catchErrorMap" class="anchor"></a><code><span class="keyword">let</span> catchErrorMap: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-catchErrorApply"><a href="#val-catchErrorApply" class="anchor"></a><code><span class="keyword">let</span> catchErrorApply: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-catchErrorFlatMap"><a href="#val-catchErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> catchErrorFlatMap: a r0 e1 e2. <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e1</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dt class="spec value" id="val-handleError"><a href="#val-handleError" class="anchor"></a><code><span class="keyword">let</span> handleError: a e. <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â Relude_Void.t)</span>;</code></dt><dd><p>Uses a function to convert an error value to a success value, which serves to &quot;clear&quot; the error in the IO, thereby making the error type <code>Void.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-mapHandleError"><a href="#val-mapHandleError" class="anchor"></a><code><span class="keyword">let</span> mapHandleError: a e b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â Relude_Void.t)</span>;</code></dt><dd><p>Maps the success channel and handles an error on the error channel to end up with an IO of a new type with a voided error channel</p></dd></dl><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: a b e1 e2. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'e1</span> <span>=&gt;</span> <span class="type-var">'e2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e1</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e2</span>)</span>;</code></dt><dd><p>Applies functions on both the success and error channels of the <code>IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-bitap"><a href="#val-bitap" class="anchor"></a><code><span class="keyword">let</span> bitap: a e. <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Same as <code>tap</code>, but works on both the success and error channels simultaneously.</p></dd></dl><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">let</span> alt: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Returns a new <code>IO</code> that when run, will attempt the <code>IO</code> given as the first argument, and if it fails, will attempt the <code>IO</code> given as the second argument. The second <code>IO</code> is only run if the first fails.</p><p>The <code>&lt;|&gt;</code> operator version of <code>alt</code> can be accessed via the <code>IO.WithError</code> module functor, like this:</p><pre><code class="ml">module IOE = IO.WithError({ type t = string; });

let a = ref(false);
let b = ref(false);

IOE.Infix.(
  IO.suspend(() =&gt; a := true)
  &lt;|&gt; IO.suspend(() =&gt; b := true) // this effect won't run in this case, because the previous IO succeeds
  |&gt; IO.unsafeRunAsync(...)
);</code></pre></dd></dl><dl><dt class="spec value" id="val-align"><a href="#val-align" class="anchor"></a><code><span class="keyword">let</span> align: a b e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates a new IO that will run the two input IO effects in parallel, and resolve if either or both succeed.</p></dd></dl><dl><dt class="spec value" id="val-alignWith"><a href="#val-alignWith" class="anchor"></a><code><span class="keyword">let</span> alignWith: a b c e. <span>(Relude_Ior_Type.t<span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'c</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates a new IO that runs two effects in parallel, and if either or both succeed, convert the result into another type 'c</p></dd></dl><dl><dt class="spec value" id="val-orElse"><a href="#val-orElse" class="anchor"></a><code><span class="keyword">let</span> orElse: a e. <span>fallback:<a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span></span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Returns a new <code>IO</code> that when run, will attempt the <code>IO</code> given as the second, un-labeled argument, and if it fails, will attempt the <code>IO</code> given as the first argument with the label ~fallback.</p><p>This is intended to be used with the <code>|&gt;</code> pipe operator, like this:</p><pre><code class="ml">IO.suspend(() =&gt; a := true)
|&gt; IO.orElse(~fallback=IO.suspend(() =&gt; b := true))
|&gt; IO.unsafeRunAsync(...)</code></pre></dd></dl><dl><dt class="spec value" id="val-tries"><a href="#val-tries" class="anchor"></a><code><span class="keyword">let</span> tries: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â exn)</span>;</code></dt><dd><p>Lifts a side-effect function that might throw an exception into a suspended <code>IO.t('a, exn)</code> value.</p><p>The <code>exn</code> type is OCaml's extensible error type.</p></dd></dl><dl><dt class="spec value" id="val-triesJS"><a href="#val-triesJS" class="anchor"></a><code><span class="keyword">let</span> triesJS: a. <span>(unit <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â Js.Exn.t)</span>;</code></dt><dd><p>Lifts a side-effect function that might throw an JS exception into a suspended <code>IO.t('a, Js.Exn.t)</code> value.</p><p>If a normal <code>Js.Exn.t</code> is throw, it is captured as-is, but if the thrown object is not a <code>Js.Exn.t</code> it is unsafely coerced into a <code>Js.Exn.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">let</span> flip: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>,Â <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Flips the values between the success and error channels.</p></dd></dl><dl><dt class="spec value" id="val-flipMap"><a href="#val-flipMap" class="anchor"></a><code><span class="keyword">let</span> flipMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>,Â <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-flipApply"><a href="#val-flipApply" class="anchor"></a><code><span class="keyword">let</span> flipApply: a r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>,Â <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-flipFlatMap"><a href="#val-flipFlatMap" class="anchor"></a><code><span class="keyword">let</span> flipFlatMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'e</span>,Â <span class="type-var">'a</span>)</span>;</code></dt><dt class="spec value" id="val-summonError"><a href="#val-summonError" class="anchor"></a><code><span class="keyword">let</span> summonError: a e. <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span>;</code></dt><dd><p>Summons an error of type <code>'e</code> from the error channel into the success channel as a <code>result('a, 'e)</code>. The error channel becomes <code>Void.t</code> because the error has been (re)moved.</p></dd></dl><dl><dt class="spec value" id="val-summonErrorMap"><a href="#val-summonErrorMap" class="anchor"></a><code><span class="keyword">let</span> summonErrorMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-summonErrorApply"><a href="#val-summonErrorApply" class="anchor"></a><code><span class="keyword">let</span> summonErrorApply: a r0 e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> <span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-summonErrorFlatMap"><a href="#val-summonErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> summonErrorFlatMap: a r0 e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span>;</code></dt><dt class="spec value" id="val-unsummonError"><a href="#val-unsummonError" class="anchor"></a><code><span class="keyword">let</span> unsummonError: a e. <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Unsummons an error from a success channel <code>result('a, 'e)</code> back into the error channel of the <code>IO</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsummonErrorMap"><a href="#val-unsummonErrorMap" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorMap: r0 a e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-unsummonErrorApply"><a href="#val-unsummonErrorApply" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorApply: r0 a e. <a href="#type-t">t</a><span>(<span class="type-var">'r0</span> <span>=&gt;</span> Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-unsummonErrorFlatMap"><a href="#val-unsummonErrorFlatMap" class="anchor"></a><code><span class="keyword">let</span> unsummonErrorFlatMap: r0 a e. <span>(<span class="type-var">'r0</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(Pervasives.result<span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>,Â Relude_Void.t)</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'r0</span>,Â Relude_Void.t)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dt class="spec value" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">let</span> delay: e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(unit,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Creates an async <code>IO</code> that waits for the given millisecond timeout before completing with a unit value.</p></dd></dl><dl><dt class="spec value" id="val-delayWithVoid"><a href="#val-delayWithVoid" class="anchor"></a><code><span class="keyword">let</span> delayWithVoid: int <span>=&gt;</span> <a href="#type-t">t</a><span>(unit,Â Relude_Void.t)</span>;</code></dt><dd><p>Creates an async non-failing <code>IO</code> that waits for the given millisecond timeout before completing with a unit value.</p></dd></dl><dl><dt class="spec value" id="val-withDelayAfter"><a href="#val-withDelayAfter" class="anchor"></a><code><span class="keyword">let</span> withDelayAfter: a e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Injects a delay in milliseconds after the given IO. The value or error from the previous IO is propagated after the delay.</p><p>When run, the given IO will be run first, then the delay will be run after the IO finishes.</p><pre><code class="ml">IO.pure(4) |&gt; IO.withDelayAfter(2000) |&gt; ...</code></pre></dd></dl><dl><dt class="spec value" id="val-withDelay"><a href="#val-withDelay" class="anchor"></a><code><span class="keyword">let</span> withDelay: int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Alias for withDelayAfter</p></dd></dl><dl><dt class="spec value" id="val-withDelayBefore"><a href="#val-withDelayBefore" class="anchor"></a><code><span class="keyword">let</span> withDelayBefore: a e. int <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>Injects a delay before the given IO.</p><p>When run, the delay will be executed first, then the given IO</p></dd></dl><dl><dt class="spec value" id="val-debounce"><a href="#val-debounce" class="anchor"></a><code><span class="keyword">let</span> debounce: r a e. <span>?&#8288;immediate:bool</span> <span>=&gt;</span> <span>?&#8288;intervalMs:int</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(option(<span class="type-var">'a</span>),Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>This will &quot;debounce&quot; an IO so that it will only allow the latest call within some interval to go through. All other calls will be cancelled.</p><p>Note: that the IO produced by this function is not referentially transparent, because the IO chain is manipulated at runtime via a mutable ref.</p><pre><code class="ml">let ioLog = messageToLog =&gt; IO.pure() |&gt; IO.map(() =&gt; Js.log(messageToLog));
let debouncedIoLog = IO.debounce(ioLog);

&quot;This message will not get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore);
&quot;This message will also not get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore);
&quot;This message will get logged&quot; |&gt; debouncedIoLog |&gt; IO.unsafeRunAsync(ignore);</code></pre></dd></dl><dl><dt class="spec value" id="val-throttle"><a href="#val-throttle" class="anchor"></a><code><span class="keyword">let</span> throttle: r a e. <span>?&#8288;intervalMs:int</span> <span>=&gt;</span> <span>(<span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>)</span> <span>=&gt;</span> <span class="type-var">'r</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(option(<span class="type-var">'a</span>),Â <span class="type-var">'e</span>)</span>;</code></dt><dd><p>This will &quot;throttle&quot; an IO so that it will only allow subsequent calls to go through after some period of time has elapsed.</p><p>Note: that the IO produced by this function is not referentially transparent, because the IO chain is manipulated at runtime via a mutable ref.</p><pre><code class="ml">let ioLog = messageToLog =&gt; IO.pure() |&gt; IO.map(() =&gt; Js.log(messageToLog));
let throttledIoLog = IO.throttled(ioLog);

&quot;This message will get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore);
&quot;This message will not get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore);
&quot;This message will also not get logged&quot; |&gt; throttledIoLog |&gt; IO.unsafeRunAsync(ignore);</code></pre></dd></dl><div class="spec module" id="module-Bifunctor"><a href="#module-Bifunctor" class="anchor"></a><code><span class="keyword">module</span> Bifunctor: BsBastet.Interface.BIFUNCTOR <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Bifunctor">Bifunctor</a>.t('a, 'e) = <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'e</span>)</span>;</code></div><dl><dt class="spec value" id="val-bimap"><a href="#val-bimap" class="anchor"></a><code><span class="keyword">let</span> bimap: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'a</span>,Â <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>,Â <span class="type-var">'d</span>)</span>;</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><dl><dt class="spec value" id="val-mapLeft"><a href="#val-mapLeft" class="anchor"></a><code><span class="keyword">let</span> mapLeft: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>,Â <span class="type-var">'b</span>)</span>;</code></dt><dt class="spec value" id="val-mapRight"><a href="#val-mapRight" class="anchor"></a><code><span class="keyword">let</span> mapRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'a</span>,Â <span class="type-var">'d</span>)</span>;</code></dt><dt class="spec value" id="val-mapError"><a href="#val-mapError" class="anchor"></a><code><span class="keyword">let</span> mapError: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>,Â <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Bifunctor">Bifunctor</a>.t<span>(<span class="type-var">'c</span>,Â <span class="type-var">'b</span>)</span>;</code></dt></dl></details></div></div></div><dl><dt class="spec module" id="module-WithError"><a href="#module-WithError" class="anchor"></a><code><span class="keyword">module</span> <a href="WithError">WithError</a>:  (<a href="WithError#argument-1-E">E</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> { ... };</code></dt><dd><p>Because this is a bifunctor, we need to use a module functor to lock in the error type, so we can implement many of the single-type parameter typeclasses.</p></dd></dl></div></body></html>