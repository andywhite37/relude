<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MonadExtensions (api.Relude_Extensions_Monad.MonadExtensions)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> â€“ <a href="../../">api</a> &#x00BB; <a href="../">Relude_Extensions_Monad</a> &#x00BB; MonadExtensions</nav><h1>Module <code>Relude_Extensions_Monad.MonadExtensions</code></h1><p><code>Extensions.Monad</code> contains a module functor <code>MonadExtensions</code> which gives you access to a wide variety of functions and infix operators that you can get &quot;for free&quot; when you have a <code>Monad</code> typeclass instance.</p><p>Extensions for any MONAD</p></header><h3 class="heading">Parameters</h3><ul><li><code>M: BsBastet.Interface.MONAD</code></li></ul><h3 class="heading">Signature</h3><div class="spec module" id="module-BsMonadExtensions"><a href="#module-BsMonadExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsMonadExtensions">BsMonadExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-flatMap"><a href="#val-flatMap" class="anchor"></a><code><span class="keyword">let</span> flatMap: a b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'b</span>);</code></dt><dd><p>Flipped version of <code>bind</code> which has the function on the left and the monad on the right. We're calling this <code>flatMap</code> because the signature closely resembles the signature of <code>map</code> with the function on the left, and <code>flatMap</code> is another commonly used name for <code>bind</code>.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">let</span> flatten: a. <a href="#argument-1-M">M</a>.t(<a href="#argument-1-M">M</a>.t(<span class="type-var">'a</span>)) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'a</span>);</code></dt><dd><p>Flattens a nested monadic structure one time.</p></dd></dl><dl><dt class="spec value" id="val-composeKleisli"><a href="#val-composeKleisli" class="anchor"></a><code><span class="keyword">let</span> composeKleisli: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'c</span>))</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'c</span>);</code></dt><dd><p>Creates a new monadic function by composing two monadic functions from left-to-right.</p></dd></dl><dl><dt class="spec value" id="val-flipComposeKleisli"><a href="#val-flipComposeKleisli" class="anchor"></a><code><span class="keyword">let</span> flipComposeKleisli: a b c. <span>(<span class="type-var">'b</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'c</span>))</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'c</span>);</code></dt><dd><p>Creates a new monadic function by composing two monadic functions from right-to-left.</p></dd></dl><dl><dt class="spec value" id="val-liftM1"><a href="#val-liftM1" class="anchor"></a><code><span class="keyword">let</span> liftM1: a b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(<span class="type-var">'b</span>);</code></dt><dd><p>Lifts a pure function <code>'a =&gt; 'b</code> into a monadic context <code>M.t('a) =&gt; M.t('b)</code></p></dd></dl><dl><dt class="spec value" id="val-when_"><a href="#val-when_" class="anchor"></a><code><span class="keyword">let</span> when_: <a href="#argument-1-M">M</a>.t(bool) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(unit) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(unit);</code></dt><dd><p>Runs a monadic effect if the given monadic condition is evaluated to true. If the condition is false, a pure unit value is returned with no effect being run.</p></dd></dl><dl><dt class="spec value" id="val-unless"><a href="#val-unless" class="anchor"></a><code><span class="keyword">let</span> unless: <a href="#argument-1-M">M</a>.t(bool) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(unit) <span>=&gt;</span> <a href="#argument-1-M">M</a>.t(unit);</code></dt><dd><p>Runs a monadic effect if the given monadic condition is evaluated to false. If the condition is true, a pure unit value is returned with no effect being run.</p></dd></dl></div></body></html>